{# =============================== #}
{# File: mindstack_app/modules/learning/quiz/individual/templates/quiz/individual/quiz_session_single.html #}
{# Phiên bản: 4.4 (Responsive Split - Client-Side Toggle) #}
{# =============================== #}

{% extends "base.html" %}

{% block title %}Làm bài Quiz{% endblock %}

{% block head %}
{{ super() }}
<link rel="stylesheet" href="{{ url_for('learning.quiz_learning.static', filename='css/session_single.css') }}">
{% endblock %}

{% block content %}
{# Include BOTH partials, visibility controlled by CSS classes in files (lg:hidden vs hidden lg:block) #}
{% include "quiz/individual/session/default/_quiz_session_single_mobile.html" %}
{% include "quiz/individual/session/default/_quiz_session_single_desktop.html" %}

{# Hub Modal (Shared structure but styled for Desktop via CSS overrides) #}
<div id="explanation-hub-modal" class="qb-modal-overlay">
    <div class="qb-modal-container desktop:max-w-xl desktop:mx-auto desktop:h-[80vh] desktop:rounded-2xl">
        <div class="qb-hub-header">
            <h3 class="font-bold text-slate-800 text-lg">Chi tiết & Học tập</h3>
            <button id="close-hub-btn"
                class="w-8 h-8 rounded-full bg-slate-100 text-slate-600 flex items-center justify-center hover:bg-slate-200"><i
                    class="fa-solid fa-xmark"></i></button>
        </div>
        <div class="qb-hub-tabs">
            <div class="qb-hub-tab-item active" data-target="hub-expl">📖 Giải thích</div>
            <div class="qb-hub-tab-item" data-target="hub-ai">🤖 AI Coach</div>
            <div class="qb-hub-tab-item" data-target="hub-note">📝 Ghi chú</div>
        </div>
        <div class="qb-hub-content">
            <!-- Expl Tab -->
            <div id="hub-expl" class="qb-hub-pane active">
                <div class="p-4 bg-blue-50 rounded-xl border border-blue-100 text-slate-700 leading-relaxed">
                    <h4 class="font-bold text-blue-800 mb-2"><i class="fa-solid fa-circle-info"></i> Giải thích:</h4>
                    <div id="hub-explanation-text">Chưa có giải thích.</div>
                </div>
            </div>
            <!-- AI Tab -->
            <div id="hub-ai" class="qb-hub-pane">
                <div class="bg-gradient-to-r from-indigo-50 to-purple-50 p-4 rounded-xl border border-indigo-100 mb-4">
                    <div class="flex items-center justify-between mb-3">
                        <div class="flex items-center gap-2 text-indigo-700 font-bold"><i class="fa-solid fa-robot"></i>
                            <span>AI Phân Tích</span>
                        </div>
                        <button id="ai-generate-btn"
                            class="text-xs bg-white text-indigo-600 px-3 py-1.5 rounded-lg border border-indigo-200 font-semibold shadow-sm"><i
                                class="fa-solid fa-wand-magic-sparkles"></i> Tạo mới</button>
                    </div>
                    <div id="hub-ai-content"
                        class="content-display markdown-body text-sm text-slate-700 leading-relaxed min-h-[100px]">Nhấn
                        nút để yêu cầu AI phân tích...</div>
                </div>
            </div>
            <!-- Note Tab -->
            <div id="hub-note" class="qb-hub-pane">
                <div class="flex justify-between items-center mb-2">
                    <h4 class="font-bold text-slate-700">Ghi chú của bạn</h4>
                    <button id="hub-note-edit-btn"
                        class="hidden text-xs bg-blue-100 text-blue-600 border border-blue-200 px-3 py-1.5 rounded hover:bg-blue-200 font-medium">
                        <i class="fa-solid fa-pencil"></i> Sửa ghi chú
                    </button>
                </div>

                <!-- Display Mode -->
                <div id="hub-note-display-mode" class="hidden">
                    <div id="hub-note-content"
                        class="content-display min-h-[100px] bg-slate-50 p-3 rounded-lg text-slate-700 whitespace-pre-wrap">
                    </div>
                </div>

                <!-- Edit Mode -->
                <div id="hub-note-edit-mode" class="hidden">
                    <textarea id="hub-note-input"
                        class="w-full p-3 rounded-xl border border-slate-200 text-sm bg-slate-50 focus:bg-white focus:ring-2 focus:ring-blue-200 outline-none transition"
                        rows="8" placeholder="Ghi chú của bạn..."></textarea>
                    <div class="flex justify-end mt-2 gap-2">
                        <button id="hub-note-cancel"
                            class="cm-btn bg-white hover:bg-slate-100 text-slate-600 border border-slate-300 py-1.5 px-4 text-sm rounded-md">Hủy</button>
                        <button id="hub-note-save"
                            class="cm-btn bg-blue-600 text-white hover:bg-blue-700 py-1.5 px-4 text-sm rounded-md">Lưu
                            ghi chú</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<!-- Edit Item Modal -->
<div id="edit-item-modal" class="qb-modal-overlay">
    <div class="qb-modal-container"
        style="max-width: 900px; margin: 0 auto; height: 90vh; top: 50%; bottom: auto; transform: translate(0, -50%) scale(1); border-radius: 1rem;">
        <div class="qb-hub-header">
            <h3 class="font-bold text-slate-800 text-lg"><i
                    class="fa-solid fa-pen-to-square text-blue-600 mr-2"></i>Chỉnh sửa câu hỏi</h3>
            <button id="close-edit-modal-btn"
                class="w-8 h-8 rounded-full bg-slate-100 text-slate-600 flex items-center justify-center hover:bg-slate-200"><i
                    class="fa-solid fa-xmark"></i></button>
        </div>
        <div class="flex-1 bg-slate-50 relative overflow-hidden">
            <iframe id="edit-item-iframe" src="" class="w-full h-full border-none" title="Edit Item"></iframe>
        </div>
    </div>
</div>

<!-- Feedback Modal -->
<div id="feedback-modal" class="qb-modal-overlay">
    <div class="qb-modal-container"
        style="max-width: 500px; margin: 0 auto; height: auto; top: 50%; bottom: auto; transform: translate(0, -50%) scale(1); border-radius: 1rem;">
        <div class="qb-hub-header">
            <h3 class="font-bold text-slate-800 text-lg"><i class="fa-solid fa-flag text-red-500 mr-2"></i>Báo lỗi / Góp
                ý</h3>
            <button id="close-feedback-btn"
                class="w-8 h-8 rounded-full bg-slate-100 text-slate-600 flex items-center justify-center hover:bg-slate-200"><i
                    class="fa-solid fa-xmark"></i></button>
        </div>
        <div class="p-4">
            <p class="text-sm text-slate-600 mb-3">Hãy mô tả vấn đề bạn gặp phải với câu hỏi này. Đóng góp của bạn giúp
                chúng tôi cải thiện chất lượng!</p>
            <textarea id="feedback-input"
                class="w-full p-3 rounded-xl border border-slate-200 text-sm bg-slate-50 focus:bg-white focus:ring-2 focus:ring-blue-200 outline-none transition mb-4"
                rows="4" placeholder="Nhập nội dung phản hồi..."></textarea>
            <div class="flex justify-end gap-2">
                <button id="feedback-cancel-btn"
                    class="cm-btn bg-white hover:bg-slate-100 text-slate-600 border border-slate-300 py-2 px-4 text-sm rounded-lg">Hủy</button>
                <button id="feedback-submit-btn"
                    class="cm-btn bg-blue-600 text-white hover:bg-blue-700 py-2 px-4 text-sm rounded-lg">Gửi phản
                    hồi</button>
            </div>
        </div>
    </div>
</div>
<link rel="stylesheet" href="{{ url_for('learning.quiz_learning.static', filename='css/session_single.css') }}">
{% endblock %}

{% block scripts %}
{{ super() }}
<script>
    (function () {
        // URLs & Meta
        const getQuestionBatchUrl = "{{ url_for('learning.quiz_learning.get_question_batch') }}";
        const submitAnswerBatchUrl = "{{ url_for('learning.quiz_learning.submit_answer_batch') }}";
        const quizDashboardUrl = "{{ url_for('learning.quiz_learning.quiz_learning_dashboard') }}";
        const getAiResponseUrl = "{{ url_for('ai_services.get_ai_response') }}";
        const saveNoteUrlTemplate = "{{ url_for('notes.save_note', item_id=0) }}";
        const transcriptUrlTemplate = "{{ url_for('learning.quiz_learning.get_quiz_transcript', item_id=0) }}";
        const csrfToken = document.querySelector('meta[name="csrf-token"]')?.getAttribute('content') || '';
        const SESSION_KEY = 'quiz_session_single_state';

        // --- State ---
        let currentBatch = [];
        let currentIndex = 0;
        let userAnswers = {};
        let sessionStats = { total: 0, correct: 0, total_questions: 0 };
        let currentQuestion = null;
        let lastAnswerResult = null; // Holds the result of the last answered question

        // Helper: Update text/html for ALL matching elements (Mobile & Desktop)
        const setText = (selector, text) => document.querySelectorAll(selector).forEach(el => el.textContent = text);
        const setHtml = (selector, html) => document.querySelectorAll(selector).forEach(el => el.innerHTML = html);
        const toggleClass = (selector, cls, force) => document.querySelectorAll(selector).forEach(el => el.classList.toggle(cls, force));

        // Elements (Single selections for event binding)
        const dom = {
            // Hub
            hubModal: document.getElementById('explanation-hub-modal'),
            openHubBtn: document.getElementById('open-hub-btn'),
            openHubDesktopBtn: document.getElementById('open-hub-desktop-btn'),
            closeHubBtn: document.getElementById('close-hub-btn'),
            hubExplText: document.getElementById('hub-explanation-text'),
            hubAiContent: document.getElementById('hub-ai-content'),
            aiGenerateBtn: document.getElementById('ai-generate-btn'),
            hubNoteInput: document.getElementById('hub-note-input'),
            hubNoteSave: document.getElementById('hub-note-save'),
        };

        // --- State Management ---
        function saveState() {
            const state = {
                currentBatch,
                currentIndex,
                userAnswers,
                sessionStats,
                lastAnswerResult
            };
            sessionStorage.setItem(SESSION_KEY, JSON.stringify(state));
        }

        function loadState() {
            const savedState = sessionStorage.getItem(SESSION_KEY);
            if (!savedState) return false;

            try {
                const state = JSON.parse(savedState);
                currentBatch = state.currentBatch || [];
                currentIndex = state.currentIndex || 0;
                userAnswers = state.userAnswers || {};
                sessionStats = state.sessionStats || { total: 0, correct: 0, total_questions: 0 };
                lastAnswerResult = state.lastAnswerResult || null;

                if (currentBatch.length === 0 || currentIndex >= currentBatch.length) {
                    clearState();
                    return false;
                }

                currentQuestion = currentBatch[currentIndex];

                // Restore UI
                showLoading(false);
                renderQuestion(currentQuestion);
                updateStatsUI();

                // Restore answered state if applicable
                const answered = lastAnswerResult && lastAnswerResult.item_id === currentQuestion.item_id;
                if (answered) {
                    showFeedback(lastAnswerResult);
                    updateActionButtons(false, '<i class="fa-solid fa-arrow-right"></i> Tiếp theo', 'next');
                    if (dom.openHubBtn) dom.openHubBtn.classList.remove('hidden');
                } else {
                    // Restore selected option if not yet answered
                    const selected = userAnswers[currentQuestion.item_id];
                    if (selected) {
                        selectOption(selected);
                    }
                }
                return true;
            } catch (e) {
                console.error("Error loading state:", e);
                clearState();
                return false;
            }
        }

        function clearState() {
            sessionStorage.removeItem(SESSION_KEY);
        }

        // --- Core Logic ---

        async function loadFreshBatch() {
            showLoading(true);
            try {
                const res = await fetch(getQuestionBatchUrl, { headers: { 'X-Requested-With': 'XMLHttpRequest' } });
                if (!res.ok) {
                    if (res.status === 404) return finishSession();
                    throw new Error('Load failed');
                }
                const data = await res.json();
                currentBatch = data.items || [];
                currentIndex = 0;
                userAnswers = {};
                lastAnswerResult = null;

                // Init Session Stats
                sessionStats.total_questions = data.total_question_groups_in_session || data.total_items_in_session || 0;
                sessionStats.total = data.session_total_answered || 0;
                sessionStats.correct = data.session_correct_answers || 0;

                if (currentBatch.length > 0) {
                    renderQuestion(currentBatch[currentIndex]);
                    updateStatsUI();
                    saveState();
                } else {
                    finishSession();
                }
            } catch (e) {
                console.error(e);
                alert('Lỗi tải câu hỏi. Vui lòng thử lại.');
            } finally {
                showLoading(false);
            }
        }

        function renderQuestion(q) {
            currentQuestion = q;
            const qNum = (sessionStats.total + currentIndex + 1);
            setText('.js-question-header', `Câu hỏi ${qNum}`);
            setHtml('.js-question-text', q.content.question);

            // Media
            const mediaContainer = document.querySelectorAll('.js-question-media');
            const transcriptBtn = document.getElementById('desktop-transcript-btn');

            let mediaHtml = '';
            let hasMedia = false;
            let hasAudio = false;

            if (q.content.question_image_file) {
                mediaHtml += `<img src="${q.content.question_image_file}" alt="Question Image" class="max-w-full h-auto rounded-lg mx-auto mb-4 border border-slate-200">`;
                hasMedia = true;
            }
            if (q.content.question_audio_file) {
                mediaHtml += `<div class="mt-2 mb-4 w-full flex justify-center"><audio controls class="w-full max-w-md"><source src="${q.content.question_audio_file}" type="audio/mpeg">Your browser does not support the audio element.</audio></div>`;
                hasMedia = true;
                hasAudio = true;
            }

            mediaContainer.forEach(el => {
                if (hasMedia) {
                    el.innerHTML = mediaHtml;
                    el.classList.remove('hidden');
                } else {
                    el.innerHTML = '';
                    el.classList.add('hidden');
                }
            });

            // Toggle Transcript Button (Both Mobile & Desktop)
            // USER REQUEST: Only show transcript AFTER answering.
            // So we hide it initially here.
            const mobileTranscriptBtn = document.getElementById('mobile-transcript-btn');

            if (transcriptBtn) transcriptBtn.classList.add('hidden');
            if (mobileTranscriptBtn) mobileTranscriptBtn.classList.add('hidden');

            /* Original Logic (Show immediately) - Disabled
            if (hasAudio) {
                if (transcriptBtn) transcriptBtn.classList.remove('hidden');
                if (mobileTranscriptBtn) mobileTranscriptBtn.classList.remove('hidden');
            } else {
                if (transcriptBtn) transcriptBtn.classList.add('hidden');
                if (mobileTranscriptBtn) mobileTranscriptBtn.classList.add('hidden');
            }
            */

            // Options
            const desktopGrid = document.querySelector('.hidden.lg\\:block .js-options-grid');
            const mobileGrid = document.querySelector('.lg\\:hidden .js-options-grid');

            const optionsHtmlMobile = Object.entries(q.content.options || {}).map(([key, val]) => `
            <div class="qb-option-label" data-key="${key}">
                <span class="qb-option-letter-circle">${key}</span>
                <span class="text-slate-800 font-medium text-lg leading-tight mt-1">${val}</span>
            </div>
        `).join('');

            const optionsHtmlDesktop = Object.entries(q.content.options || {}).map(([key, val]) => `
            <button class="option-button" data-option="${key}">
                <span class="option-key">${key}</span>
                <span>${val}</span>
            </button>
        `).join('');

            if (mobileGrid) {
                mobileGrid.innerHTML = optionsHtmlMobile;
                mobileGrid.querySelectorAll('.qb-option-label').forEach(el => el.addEventListener('click', () => selectOption(el.dataset.key)));
            }
            if (desktopGrid) {
                desktopGrid.innerHTML = optionsHtmlDesktop;
                desktopGrid.querySelectorAll('.option-button').forEach(el => el.addEventListener('click', () => selectOption(el.dataset.option)));
            }

            // Reset UI
            toggleClass('.js-result-panel', 'hidden', true);
            toggleClass('#desktop-insights-area', 'hidden', true);
            if (dom.openHubBtn) dom.openHubBtn.classList.add('hidden');

            updateActionButtons(true, '<i class="fa-solid fa-paper-plane"></i> Gửi đáp án', 'submit');

            // Reset Content
            setText('#hub-explanation-text', "Chưa có giải thích.");
            setHtml('#desktop-explanation-content', "");
            toggleClass('#desktop-explanation', 'hidden', true);

            const aiDefault = "Nhấn nút để yêu cầu AI phân tích...";
            setText('#hub-ai-content', aiDefault);
            setHtml('#desktop-ai-content', `<span class="italic text-slate-500">${aiDefault}</span>`);

            // Reset AI Buttons
            const aiBtns = [document.getElementById('ai-generate-btn'), document.getElementById('desktop-ai-generate-btn')];
            aiBtns.forEach(btn => {
                if (btn) {
                    btn.classList.remove('hidden');
                    btn.disabled = false;
                }
            });

            // Update note UI based on whether note exists
            const noteVal = q.note_content || "";
            updateNoteUI(noteVal);
            updateDesktopNoteUI(noteVal);

            // Edit & Feedback Buttons - Reset to hidden state
            const mobileEditBtn = document.getElementById('mobile-edit-btn');
            const desktopEditBtn = document.getElementById('desktop-edit-btn');
            const mobileFeedbackBtn = document.getElementById('mobile-feedback-btn');

            if (mobileEditBtn) mobileEditBtn.classList.add('hidden');
            if (desktopEditBtn) desktopEditBtn.classList.add('hidden');
            if (mobileFeedbackBtn) mobileFeedbackBtn.classList.add('hidden');
        }

        function selectOption(key) {
            if (lastAnswerResult && lastAnswerResult.item_id === currentQuestion.item_id) return; // Don't allow re-selecting after answering

            document.querySelectorAll(`.qb-option-label, .option-button`).forEach(el => {
                const elKey = el.dataset.key || el.dataset.option;
                el.classList.toggle('selected', elKey === key);
            });

            userAnswers[currentQuestion.item_id] = key;
            updateActionButtons(false, null, null, true);
            saveState();
        }

        async function submitAnswer() {
            const itemId = currentQuestion.item_id;
            const answer = userAnswers[itemId];
            if (!answer) return;

            updateActionButtons(true, '<i class="fas fa-circle-notch fa-spin"></i> Đang gửi...');

            try {
                const res = await fetch(submitAnswerBatchUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken },
                    body: JSON.stringify({ answers: [{ item_id: itemId, user_answer: answer }] })
                });
                const data = await res.json();
                lastAnswerResult = data.results[0]; // Save result

                // Update Local Stats immediately
                if (currentQuestion.user_stats) {
                    const s = currentQuestion.user_stats;
                    s.times_answered++;
                    s.last_reviewed = "Vừa xong";

                    const isCorrect = lastAnswerResult.is_correct;
                    if (isCorrect) {
                        s.correct_count++;
                        s.streak++;
                    } else {
                        s.incorrect_count++;
                        s.streak = 0;
                    }
                    s.accuracy = Math.round((s.correct_count / s.times_answered) * 1000) / 10; // Round to 1 decimal

                    // Add to history
                    if (!s.recent_history) s.recent_history = [];
                    s.recent_history.unshift({
                        timestamp: new Date().toISOString(),
                        user_answer: answer,
                        is_correct: isCorrect
                    });
                    if (s.recent_history.length > 5) s.recent_history.pop();

                    // Force UI Update
                    setText('.js-qstat-times', s.times_answered);
                    setText('.js-qstat-accuracy', s.accuracy + '%');
                    setText('.js-qstat-streak', s.streak);
                    setText('.js-qstat-last', s.last_reviewed);
                    setText('.js-qstat-correct', s.correct_count);
                    setText('.js-qstat-incorrect', s.incorrect_count);

                    // Update History List UI
                    const histContainer = document.querySelector('.js-qstat-history');
                    if (histContainer) {
                        const html = s.recent_history.map(h => {
                            // Helper for timestamp formatting handled purely in JS here
                            const date = new Date(h.timestamp);
                            let timeStr = "Vừa xong";
                            if (h.timestamp.indexOf('T') > 0 && !h.timestamp.includes('Vừa xong')) { // Simple check if it's ISO string
                                timeStr = date.toLocaleTimeString('vi-VN', { hour: '2-digit', minute: '2-digit', month: 'numeric', day: 'numeric' });
                            }

                            const isCorr = h.is_correct;
                            const icon = isCorr ? '<i class="fa-solid fa-check text-emerald-500"></i>' : '<i class="fa-solid fa-xmark text-rose-500"></i>';
                            const ans = h.user_answer || '?';
                            return `
                                <div class="flex justify-between items-center bg-slate-50 p-2 rounded border border-slate-100">
                                    <span class="text-xs text-slate-500">${timeStr}</span>
                                    <div class="flex items-center gap-2">
                                        <span class="font-bold text-slate-700">Chọn ${ans}</span>
                                        ${icon}
                                    </div>
                                </div>
                            `;
                        }).join('');
                        histContainer.innerHTML = html;
                    }
                }

                showFeedback(lastAnswerResult);

                sessionStats.total++;
                if (lastAnswerResult.is_correct) sessionStats.correct++;
                updateStatsUI();

                updateActionButtons(false, '<i class="fa-solid fa-arrow-right"></i> Tiếp theo', 'next');
                if (dom.openHubBtn) dom.openHubBtn.classList.remove('hidden');

                saveState(); // Save state after getting feedback
            } catch (e) {
                console.error(e);
                alert('Lỗi gửi đáp án.');
                updateActionButtons(false);
            }
        }

        function showFeedback(result) {
            if (!result || !result.correct_answer) return; // Prevent empty feedback

            document.querySelectorAll('.qb-option-label, .option-button').forEach(el => {
                const elKey = el.dataset.key || el.dataset.option;
                el.classList.add('disabled');
                el.style.pointerEvents = 'none';
                el.classList.remove('selected');
                if (elKey === result.correct_answer) el.classList.add('correct');
                if (elKey === userAnswers[result.item_id] && !result.is_correct) el.classList.add('incorrect');
            });

            // Force show lightbulb button
            if (dom.openHubBtn) dom.openHubBtn.classList.remove('hidden');

            toggleClass('.js-result-panel', 'hidden', false);
            toggleClass('#desktop-insights-area', 'hidden', false);

            if (result.is_correct) {
                setText('.js-feedback-icon', '🎉');
                setText('.js-feedback-title', 'Chính xác!');
                document.querySelectorAll('.js-feedback-title').forEach(el => el.className = 'text-lg font-bold text-emerald-600 js-feedback-title');
                document.querySelectorAll('.desktop-feedback-box').forEach(el => { el.classList.remove('incorrect'); el.classList.add('correct'); });
            } else {
                setText('.js-feedback-icon', '🤔');
                setText('.js-feedback-title', 'Sai rồi');
                document.querySelectorAll('.js-feedback-title').forEach(el => el.className = 'text-lg font-bold text-rose-600 js-feedback-title');
                document.querySelectorAll('.desktop-feedback-box').forEach(el => { el.classList.remove('correct'); el.classList.add('incorrect'); });
            }
            setText('.js-feedback-answer', result.correct_answer);

            const explanationText = result.explanation || "Chưa có giải thích.";
            const explanationHtml = explanationText.replace(/\r?\n/g, '<br>');
            if (dom.hubExplText) dom.hubExplText.innerHTML = explanationHtml;
            const dtExplContent = document.getElementById('desktop-explanation-content');
            if (dtExplContent) {
                dtExplContent.innerHTML = explanationHtml;
                document.getElementById('desktop-explanation').classList.toggle('hidden', !result.explanation);
            }

            if (currentQuestion.ai_explanation) {
                if (dom.hubAiContent) dom.hubAiContent.innerHTML = currentQuestion.ai_explanation;
                setHtml('#desktop-ai-content', currentQuestion.ai_explanation);

                // Hide generate buttons if AI explanation already exists
                document.querySelectorAll('#ai-generate-btn, #desktop-ai-generate-btn').forEach(btn => {
                    if (btn) btn.classList.add('hidden');
                });
            }

            // Reveal Edit and Feedback Buttons
            const mobileEditBtn = document.getElementById('mobile-edit-btn');
            const desktopEditBtn = document.getElementById('desktop-edit-btn');
            // FIX: Correct URL Prefix is /content/quizzes not /content_management




            const editUrl = `/content/quizzes/${currentQuestion.container_id}/items/edit/${currentQuestion.item_id}`;

            if (currentQuestion.can_edit) {
                if (mobileEditBtn) {
                    mobileEditBtn.classList.remove('hidden');
                    mobileEditBtn.onclick = (e) => {
                        e.preventDefault();
                        if (window.openEditModal) window.openEditModal(editUrl);
                    };
                }
                if (desktopEditBtn) {
                    desktopEditBtn.classList.remove('hidden');
                    desktopEditBtn.removeAttribute('href');
                    desktopEditBtn.onclick = (e) => {
                        e.preventDefault();
                        if (window.openEditModal) window.openEditModal(editUrl);
                    };
                }
            }

            // Show feedback button
            const mobileFeedbackBtn = document.getElementById('mobile-feedback-btn');
            if (mobileFeedbackBtn) mobileFeedbackBtn.classList.remove('hidden');

            // Show Transcript Button (Post-Answer)
            // Check if question has audio
            const hasAudio = (currentQuestion.content && currentQuestion.content.question_audio_file) ||
                currentQuestion.question_audio ||
                currentQuestion.audio_url;

            if (hasAudio) {
                const tBtn = document.getElementById('desktop-transcript-btn');
                const mTBtn = document.getElementById('mobile-transcript-btn');
                if (tBtn) tBtn.classList.remove('hidden');
                if (mTBtn) mTBtn.classList.remove('hidden');
            }

            // Update Question Stats (Mobile)
            // Update Question Stats (Mobile)
            if (currentQuestion.user_stats) {
                const s = currentQuestion.user_stats;
                setText('.js-qstat-times', s.times_answered);
                setText('.js-qstat-accuracy', s.accuracy + '%');
                setText('.js-qstat-streak', s.streak);
                setText('.js-qstat-last', s.last_reviewed);
                setText('.js-qstat-correct', s.correct_count);
                setText('.js-qstat-incorrect', s.incorrect_count);

                // History List
                const histContainer = document.querySelector('.js-qstat-history');
                if (histContainer && s.recent_history && s.recent_history.length > 0) {
                    const html = s.recent_history.map(h => {
                        const date = new Date(h.timestamp);
                        const timeStr = date.toLocaleTimeString('vi-VN', { hour: '2-digit', minute: '2-digit', month: 'numeric', day: 'numeric' });
                        const isCorr = h.is_correct;
                        const icon = isCorr ? '<i class="fa-solid fa-check text-emerald-500"></i>' : '<i class="fa-solid fa-xmark text-rose-500"></i>';
                        const ans = h.user_answer || '?';
                        return `
                            <div class="flex justify-between items-center bg-slate-50 p-2 rounded border border-slate-100">
                                <span class="text-xs text-slate-500">${timeStr}</span>
                                <div class="flex items-center gap-2">
                                    <span class="font-bold text-slate-700">Chọn ${ans}</span>
                                    ${icon}
                                </div>
                            </div>
                        `;
                    }).join('');
                    histContainer.innerHTML = html;
                } else if (histContainer) {
                    histContainer.innerHTML = '<div class="text-center text-xs text-slate-400 italic">Chưa có dữ liệu</div>';
                }

            } else {
                setText('.js-qstat-times', '0');
                setText('.js-qstat-accuracy', '0%');
                setText('.js-qstat-last', '--');
                setText('.js-qstat-streak', '0');
                setText('.js-qstat-correct', '0');
                setText('.js-qstat-incorrect', '0');
            }
        }

        function nextQuestion() {
            lastAnswerResult = null; // Clear last answer result before moving on
            currentIndex++;

            // Auto-switch back to Game tab if on mobile
            // Auto-close Stats Modal if open
            const statsModal = document.getElementById('mobile-stats-modal');
            if (statsModal) statsModal.classList.remove('open');

            if (currentIndex < currentBatch.length) {
                renderQuestion(currentBatch[currentIndex]);
                saveState();
            } else {
                loadFreshBatch(); // Load a new set of questions
            }
        }

        function finishSession() {
            clearState();
            alert('Đã hoàn thành phiên học!');
            window.location.href = quizDashboardUrl;
        }

        function showLoading(show) {
            toggleClass('.js-quiz-loading', 'hidden', !show);
            toggleClass('.js-quiz-content', 'hidden', show);
        }

        function updateActionButtons(disabled, text, action, primary) {
            document.querySelectorAll('#mobile-action-btn, #desktop-action-btn').forEach(btn => {
                if (!btn) return;
                if (disabled !== undefined) btn.disabled = disabled;
                if (text) btn.innerHTML = text;
                if (action) btn.dataset.action = action;
                if (primary) btn.classList.add('cm-btn-primary');
            });
        }

        function updateStatsUI() {
            const acc = sessionStats.total > 0 ? Math.round((sessionStats.correct / sessionStats.total) * 100) : 0;
            setText('.js-stat-total', sessionStats.total);
            setText('.js-stat-correct', sessionStats.correct);
            setText('.js-stat-accuracy', `${acc}%`);
            setText('.js-stat-progress-text', `${sessionStats.total}/${sessionStats.total_questions}`);
            document.querySelectorAll('.js-stat-progress-bar').forEach(el => {
                el.style.width = `${(sessionStats.total / (sessionStats.total_questions || 1)) * 100}%`;
            });
        }

        // --- Event Handlers (AI, Notes, Navigation) ---
        const handleAiGenerate = async (btn) => { /* ... (unchanged) ... */ };
        const handleSaveNote = async (btn, inputEl) => { /* ... (unchanged) ... */ };

        // ... (keep the AI and Note handlers from original script, they are self-contained) ...
        // --- AI & Notes Handlers (Unified) ---
        const handleAiGenerateImpl = async (btn) => {
            if (!btn) return;
            btn.disabled = true;
            const loadingText = "Đang tạo...";
            if (dom.hubAiContent) dom.hubAiContent.textContent = loadingText;
            setHtml('#desktop-ai-content', `<i class="fas fa-spinner fa-spin"></i> ${loadingText}`);

            try {
                const res = await fetch(getAiResponseUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken },
                    body: JSON.stringify({ item_id: currentQuestion.item_id, prompt_type: 'explanation' })
                });
                const data = await res.json();
                const content = data.html_content || data.response;

                if (dom.hubAiContent) dom.hubAiContent.innerHTML = content;
                setHtml('#desktop-ai-content', content);

                currentQuestion.ai_explanation = content;
                saveState(); // Save state after getting AI explanation

                // Hide the button after successful generation
                btn.classList.add('hidden');
            } catch (e) {
                const errHtml = '<span class="text-red-500">Lỗi khi gọi AI.</span>';
                if (dom.hubAiContent) dom.hubAiContent.innerHTML = errHtml;
                setHtml('#desktop-ai-content', errHtml);
                btn.disabled = false;
            }
        };

        const handleSaveNoteImpl = async (btn, inputEl) => {
            if (!btn || !inputEl) return;
            const originalText = btn.innerHTML;
            const content = inputEl.value;

            btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Lưu...';
            btn.disabled = true;

            try {
                await fetch(saveNoteUrlTemplate.replace('0', currentQuestion.item_id), {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken },
                    body: JSON.stringify({ content })
                });
                currentQuestion.note_content = content;

                if (dom.hubNoteInput && dom.hubNoteInput !== inputEl) dom.hubNoteInput.value = content;
                const dInput = document.getElementById('desktop-note-input');
                if (dInput && dInput !== inputEl) dInput.value = content;

                // Update UI to display mode
                updateNoteUI(content);
                updateDesktopNoteUI(content);

                alert('Đã lưu ghi chú.');
                saveState(); // Save state after saving note
            } catch (e) {
                alert('Lỗi lưu ghi chú.');
            }
            btn.innerHTML = originalText;
            btn.disabled = false;
        };

        // Function to update note UI based on content
        function updateNoteUI(noteContent) {
            const displayMode = document.getElementById('hub-note-display-mode');
            const editMode = document.getElementById('hub-note-edit-mode');
            const editBtn = document.getElementById('hub-note-edit-btn');
            const noteContentDiv = document.getElementById('hub-note-content');

            if (noteContent && noteContent.trim()) {
                // Has note - show display mode
                if (displayMode) displayMode.classList.remove('hidden');
                if (editMode) editMode.classList.add('hidden');
                if (editBtn) editBtn.classList.remove('hidden');
                if (noteContentDiv) noteContentDiv.textContent = noteContent;
                if (dom.hubNoteInput) dom.hubNoteInput.value = noteContent;
            } else {
                // No note - show edit mode
                if (displayMode) displayMode.classList.add('hidden');
                if (editMode) editMode.classList.remove('hidden');
                if (editBtn) editBtn.classList.add('hidden');
                if (dom.hubNoteInput) dom.hubNoteInput.value = '';
            }
        }

        // Function to update desktop note UI based on content
        function updateDesktopNoteUI(noteContent) {
            const displayMode = document.getElementById('desktop-note-display-mode');
            const editMode = document.getElementById('desktop-note-edit-mode');
            const editBtn = document.getElementById('desktop-note-edit-btn');
            const noteContentDiv = document.getElementById('desktop-note-content');
            const dNoteInput = document.getElementById('desktop-note-input');

            if (noteContent && noteContent.trim()) {
                // Has note - show display mode
                if (displayMode) displayMode.classList.remove('hidden');
                if (editMode) editMode.classList.add('hidden');
                if (editBtn) editBtn.classList.remove('hidden');
                if (noteContentDiv) noteContentDiv.textContent = noteContent;
                if (dNoteInput) dNoteInput.value = noteContent;
            } else {
                // No note - show edit mode
                if (displayMode) displayMode.classList.add('hidden');
                if (editMode) editMode.classList.remove('hidden');
                if (editBtn) editBtn.classList.add('hidden');
                if (dNoteInput) dNoteInput.value = '';
            }
        }

        // Bind Event Listeners
        if (dom.aiGenerateBtn) dom.aiGenerateBtn.addEventListener('click', () => handleAiGenerateImpl(dom.aiGenerateBtn));
        const dAiBtn = document.getElementById('desktop-ai-generate-btn');
        if (dAiBtn) dAiBtn.addEventListener('click', () => handleAiGenerateImpl(dAiBtn));

        if (dom.hubNoteSave) dom.hubNoteSave.addEventListener('click', () => handleSaveNoteImpl(dom.hubNoteSave, dom.hubNoteInput));
        const dNoteSave = document.getElementById('desktop-note-save');
        const dNoteInput = document.getElementById('desktop-note-input');
        if (dNoteSave) dNoteSave.addEventListener('click', () => handleSaveNoteImpl(dNoteSave, dNoteInput));

        // Note edit button - switch to edit mode
        const hubNoteEditBtn = document.getElementById('hub-note-edit-btn');
        if (hubNoteEditBtn) {
            hubNoteEditBtn.addEventListener('click', () => {
                const displayMode = document.getElementById('hub-note-display-mode');
                const editMode = document.getElementById('hub-note-edit-mode');
                if (displayMode) displayMode.classList.add('hidden');
                if (editMode) editMode.classList.remove('hidden');
                if (hubNoteEditBtn) hubNoteEditBtn.classList.add('hidden');
            });
        }

        // Note cancel button - back to display mode or hide if no content
        const hubNoteCancelBtn = document.getElementById('hub-note-cancel');
        if (hubNoteCancelBtn) {
            hubNoteCancelBtn.addEventListener('click', () => {
                const noteContent = currentQuestion?.note_content || '';
                updateNoteUI(noteContent);
            });
        }

        // Desktop note edit button - switch to edit mode
        const desktopNoteEditBtn = document.getElementById('desktop-note-edit-btn');
        if (desktopNoteEditBtn) {
            desktopNoteEditBtn.addEventListener('click', () => {
                const displayMode = document.getElementById('desktop-note-display-mode');
                const editMode = document.getElementById('desktop-note-edit-mode');
                if (displayMode) displayMode.classList.add('hidden');
                if (editMode) editMode.classList.remove('hidden');
                if (desktopNoteEditBtn) desktopNoteEditBtn.classList.add('hidden');
            });
        }

        // Desktop note cancel button - back to display mode or hide if no content
        const desktopNoteCancelBtn = document.getElementById('desktop-note-cancel');
        if (desktopNoteCancelBtn) {
            desktopNoteCancelBtn.addEventListener('click', () => {
                const noteContent = currentQuestion?.note_content || '';
                updateDesktopNoteUI(noteContent);
            });
        }

        const handleAction = () => {
            const btn = document.querySelector('#mobile-action-btn:not([disabled]), #desktop-action-btn:not([disabled])');
            if (!btn) return;
            if (btn.dataset.action === 'submit') submitAnswer();
            else nextQuestion();
        };
        document.getElementById('mobile-action-btn')?.addEventListener('click', handleAction);
        document.getElementById('desktop-action-btn')?.addEventListener('click', handleAction);


        // Mobile Tabs Logic
        // Mobile Stats Modal Logic
        const statsModal = document.getElementById('mobile-stats-modal');
        const openStatsBtn = document.getElementById('mobile-stats-btn');
        const closeStatsBtn = document.getElementById('close-stats-btn');

        if (statsModal) {
            if (openStatsBtn) openStatsBtn.addEventListener('click', () => statsModal.classList.add('open'));
            if (closeStatsBtn) closeStatsBtn.addEventListener('click', () => statsModal.classList.remove('open'));
            // Close when clicking overlay (optional)
            statsModal.addEventListener('click', (e) => {
                if (e.target === statsModal) statsModal.classList.remove('open');
            });
        }

        // Hub & Tabs
        if (dom.hubModal) {
            if (dom.openHubBtn) dom.openHubBtn.addEventListener('click', () => dom.hubModal.classList.add('open'));
            if (dom.openHubDesktopBtn) dom.openHubDesktopBtn.addEventListener('click', () => dom.hubModal.classList.add('open'));
            if (dom.closeHubBtn) dom.closeHubBtn.addEventListener('click', () => dom.hubModal.classList.remove('open'));
        }
        document.querySelectorAll('.qb-hub-tab-item').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.qb-hub-tab-item').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.qb-hub-pane').forEach(p => p.classList.remove('active'));
                tab.classList.add('active');
                document.getElementById(tab.dataset.target)?.classList.add('active');
            });
        });


        // Edit Modal Logic
        const editModal = document.getElementById('edit-item-modal');
        if (editModal) {
            const closeBtn = document.getElementById('close-edit-modal-btn');
            const iframe = document.getElementById('edit-item-iframe');

            window.openEditModal = (url) => {
                if (iframe) iframe.src = url + (url.includes('?') ? '&' : '?') + 'is_modal=true';
                editModal.classList.add('open');
            };

            const closeEditModal = () => {
                editModal.classList.remove('open');
                if (iframe) iframe.src = '';

                // Refresh current question data
                if (currentQuestion && currentQuestion.item_id) {
                    fetch(`/learn/quiz_learning/api/items/${currentQuestion.item_id}`)
                        .then(res => res.json())
                        .then(data => {
                            if (data.success && data.item) {
                                // Update current batch data
                                currentBatch[currentIndex] = { ...currentBatch[currentIndex], ...data.item };
                                // Re-render
                                renderQuestion(currentBatch[currentIndex]);
                                saveState();
                            }
                        })
                        .catch(err => console.error("Failed to refresh question:", err));
                }
            };

            if (closeBtn) closeBtn.addEventListener('click', closeEditModal);
            editModal.addEventListener('click', (e) => { if (e.target === editModal) closeEditModal(); });
        }

        // Feedback Modal Logic
        const feedbackModal = document.getElementById('feedback-modal');
        if (feedbackModal) {
            const openFeedbackBtn = document.getElementById('mobile-feedback-btn');
            const closeBtn = document.getElementById('close-feedback-btn');
            const cancelBtn = document.getElementById('feedback-cancel-btn');
            const submitBtn = document.getElementById('feedback-submit-btn');
            const input = document.getElementById('feedback-input');

            const openFeedback = () => feedbackModal.classList.add('open');
            const closeFeedback = () => feedbackModal.classList.remove('open');

            if (openFeedbackBtn) openFeedbackBtn.addEventListener('click', openFeedback);

            [closeBtn, cancelBtn].forEach(btn => btn?.addEventListener('click', closeFeedback));
            feedbackModal.addEventListener('click', (e) => { if (e.target === feedbackModal) closeFeedback(); });

            submitBtn?.addEventListener('click', () => {
                const content = input.value.trim();
                if (!content) {
                    alert("Vui lòng nhập nội dung.");
                    return;
                }
                // Simulate API call
                submitBtn.disabled = true;
                submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Đang gửi...';

                setTimeout(() => {
                    console.log(`Sending feedback for item ${currentQuestion?.item_id}: ${content}`);
                    alert("Cảm ơn đóng góp của bạn!");
                    submitBtn.disabled = false;
                    submitBtn.innerHTML = 'Gửi phản hồi';
                    input.value = '';
                    closeFeedback();
                }, 800);
            });
        }

        // Exit
        const exitHandler = () => {
            if (confirm('Kết thúc phiên làm bài?')) {
                clearState();
                window.location.href = quizDashboardUrl;
            }
        };
        document.getElementById('mobile-exit-btn')?.addEventListener('click', exitHandler);
        document.getElementById('desktop-exit-btn')?.addEventListener('click', exitHandler);


        // === TRANSCRIPT MODAL LOGIC ===
        const initTranscriptLogic = () => {
            const modal = document.getElementById('transcript-modal');
            const openBtns = [
                document.getElementById('desktop-transcript-btn'),
                document.getElementById('mobile-transcript-btn')
            ];
            const closeBtns = [
                document.getElementById('close-transcript-modal'),
                document.getElementById('close-transcript-modal-btn'),
                document.getElementById('transcript-modal-backdrop')
            ];
            const contentDiv = document.getElementById('transcript-content');
            const loadingDiv = document.getElementById('transcript-loading');
            const emptyDiv = document.getElementById('transcript-empty');
            const errorDiv = document.getElementById('transcript-error');
            const errorMsg = document.getElementById('transcript-error-msg');

            // Edit Elements
            const editBtn = document.getElementById('transcript-edit-btn');
            const editContainer = document.getElementById('transcript-edit-container');
            const editorTextarea = document.getElementById('transcript-editor');
            const editActions = document.getElementById('transcript-edit-actions');
            const saveBtn = document.getElementById('transcript-save-btn');
            const cancelBtn = document.getElementById('transcript-cancel-btn');
            const closeMainBtn = document.getElementById('transcript-close-main-btn');

            let currentTranscriptText = "";

            if (!modal) return;

            const closeModal = () => {
                modal.classList.add('hidden');
                // Don't clear content immediately so it doesn't flash empty if re-opened? 
                // Actually existing logic clears it. Stick to existing.
                contentDiv.textContent = '';
            };

            closeBtns.forEach(btn => btn?.addEventListener('click', closeModal));

            const toggleEditMode = (isEditing) => {
                if (isEditing) {
                    contentDiv.classList.add('hidden');
                    emptyDiv.classList.add('hidden');
                    editContainer.classList.remove('hidden');
                    editBtn.classList.add('hidden');
                    editActions.classList.remove('hidden');
                    closeMainBtn.classList.add('hidden');
                    editorTextarea.value = currentTranscriptText;
                } else {
                    editContainer.classList.add('hidden');
                    editActions.classList.add('hidden');
                    closeMainBtn.classList.remove('hidden');
                    contentDiv.classList.remove('hidden');
                    // Show edit button only if we have permission (handled by openTranscript)
                    // Ideally we check a flag, but for now we'll re-show it if we are just cancelling. 
                    // Real logic is inside openTranscript to set initial visibility.
                    if (modal.dataset.canEdit === "true") {
                        editBtn.classList.remove('hidden');
                    }
                }
            };

            // Save Handler
            const saveTranscript = async () => {
                const newText = editorTextarea.value;
                if (!currentQuestion || !currentQuestion.item_id) return;

                // UI Loading state
                saveBtn.disabled = true;
                saveBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';

                try {
                    const url = transcriptUrlTemplate.replace('/0', '/' + currentQuestion.item_id) + '/update';
                    const response = await fetch(url.replace('0', currentQuestion.item_id), { // Careful with replacement
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': csrfToken
                        },
                        body: JSON.stringify({ transcript: newText })
                    });

                    const data = await response.json();
                    if (data.success) {
                        currentTranscriptText = newText;
                        contentDiv.textContent = newText;
                        currentQuestion.audio_transcript = newText; // Update cache
                        toggleEditMode(false);
                    } else {
                        alert(data.message || "Lỗi khi lưu.");
                    }
                } catch (e) {
                    console.error(e);
                    alert("Lỗi kết nối khi lưu transcript.");
                } finally {
                    saveBtn.disabled = false;
                    saveBtn.textContent = 'Lưu';
                }
            };

            const openTranscript = async () => {
                if (!currentQuestion || !currentQuestion.item_id) return;

                // Show modal
                modal.classList.remove('hidden');

                // Reset UI
                loadingDiv.classList.remove('hidden');
                contentDiv.classList.add('hidden');
                emptyDiv.classList.add('hidden');
                errorDiv.classList.add('hidden');

                // Reset Edit UI
                toggleEditMode(false);
                editBtn.classList.add('hidden'); // Hide by default until we know permission
                modal.dataset.canEdit = "false";

                currentTranscriptText = "";

                try {
                    // Check local cache first?
                    // We need to check permission every time or store it in currentQuestion?
                    // Let's assume currentQuestion might have it if we fetched before.
                    // But for simplicity, we treat local cache as just text. 
                    // To get permission, we might need to hit API if not known.
                    // Compromise: If cached, show text immediately, THEN fetch ID/Permission in background?
                    // Or just always fetch. Fetch is fast.

                    // Verify audio first locally
                    const audioUrl = (currentQuestion.content && currentQuestion.content.question_audio_file) ||
                        currentQuestion.question_audio ||
                        currentQuestion.audio_url;

                    if (!audioUrl) {
                        // console.error("DEBUG: currentQuestion structure:", currentQuestion); // Removed debug log
                        throw new Error("Không tìm thấy file audio.");
                    }

                    // Call API to get text + permission
                    const url = transcriptUrlTemplate.replace('/0', '/' + currentQuestion.item_id);

                    const response = await fetch(url.replace('0', currentQuestion.item_id), {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': csrfToken
                        }
                    });

                    const data = await response.json();
                    loadingDiv.classList.add('hidden');

                    if (data.success) {
                        const text = data.transcript;
                        const canEdit = data.can_edit;

                        modal.dataset.canEdit = canEdit ? "true" : "false";

                        if (text) {
                            contentDiv.classList.remove('hidden');
                            contentDiv.textContent = text;
                            currentTranscriptText = text;
                            currentQuestion.audio_transcript = text;

                            if (canEdit) {
                                editBtn.classList.remove('hidden');
                            }
                        } else {
                            // Is empty but success? Rare case.
                            // If user can edit, let them add.
                            emptyDiv.classList.remove('hidden');
                            if (canEdit) editBtn.classList.remove('hidden');
                        }
                    } else {
                        // Handle server-side logic refusal (e.g., Not Editor)
                        // The server returns 404 now with a message if not editor.
                        // Or success=False.
                        // We should show the message in the "Empty" or "Error" area.
                        if (response.status === 404 || response.status === 403) {
                            // "Chưa có transcript... vui lòng liên hệ admin"
                            // Show this message in the empty/info area, not as a crash.
                            emptyDiv.classList.remove('hidden');
                            // Find the paragraph in emptyDiv and update it temporarily?
                            // Or just use errorDiv for clearer feedback.
                            // Let's use errorDiv for clarity if it's a "refusal".
                            // But wait, user said "nó ghi chưa có nội dung" -> probably hitting emptyDiv default text.

                            // Let's update emptyDiv text to be dynamic based on server message
                            const emptyTextP = emptyDiv.querySelector('p');
                            if (emptyTextP) emptyTextP.textContent = data.message || "Chưa có transcript.";

                        } else {
                            throw new Error(data.message || "Lỗi server.");
                        }
                    }
                } catch (e) {
                    loadingDiv.classList.add('hidden');
                    errorDiv.classList.remove('hidden');
                    if (errorMsg) errorMsg.textContent = e.message;
                }
            };

            openBtns.forEach(btn => btn?.addEventListener('click', openTranscript));

            // Attach Edit Listeners
            if (editBtn) editBtn.addEventListener('click', () => toggleEditMode(true));
            if (cancelBtn) cancelBtn.addEventListener('click', () => toggleEditMode(false));
            if (saveBtn) saveBtn.addEventListener('click', saveTranscript);

            // Allow clicking outside to close (optional, existing logic usually handles this via specific close buttons or overlay click)
        };
        initTranscriptLogic();

        // Feature: Load Quiz Set Title from LocalStorage
        function loadQuizTitleFromStorage() {
            try {
                const storedTitles = JSON.parse(localStorage.getItem('selectedQuizSetTitles') || '{}');
                const titleKeys = Object.keys(storedTitles);
                const headerSetLabel = document.querySelector('.js-quiz-set-title');

                if (headerSetLabel) {
                    if (titleKeys.length > 0) {
                        // Get the first title or a summary
                        const mainTitle = storedTitles[titleKeys[0]];
                        headerSetLabel.textContent = titleKeys.length === 1 ? mainTitle : `${mainTitle} (+${titleKeys.length - 1})`;

                        // Add tooltip via simple title attribute
                        headerSetLabel.parentElement.title = Object.values(storedTitles).join(', ');
                    } else {
                        headerSetLabel.textContent = "Phiên học Quiz";
                    }
                }
            } catch (e) {
                console.error("Lỗi khi tải tên bộ quiz:", e);
                const headerSetLabel = document.querySelector('.js-quiz-set-title');
                if (headerSetLabel) headerSetLabel.textContent = "Phiên học Quiz";
            }
        }

        // --- Init ---
        function init() {
            // Load title immediately
            loadQuizTitleFromStorage();

            // Check for force new session flag from Dashboard
            if (localStorage.getItem('force_new_session') === 'true') {
                clearState();
                localStorage.removeItem('force_new_session');
            }

            if (!loadState()) {
                loadFreshBatch();
            }
        }

        init();

    })();
</script>
{% endblock %}