<!-- mindstack_app/modules/learning/quiz/individual/templates/quiz/individual/quiz_session_batch.html -->
<!-- Phiên bản: 4.2 (Responsive Batch - with Hub & Scroll Tracking) -->
<!-- MỤC ĐÍCH: Giao diện làm bài nhiều câu hỏi (Batch) có hỗ trợ giao diện Mobile riêng biệt và chức năng Hub + Scroll Spy. -->

{% extends "base.html" %}

{% block title %}Làm bài Quiz{% endblock %}

{% block head %}
{{ super() }}
{% include 'v3/pages/content_management/shared/_shared_styles.html' %}
<link rel="stylesheet"
    href="{{ url_for('learning.serve_v3_asset', filename='quiz/individual/static/css/session_batch.css') }}">
{% endblock %}

{% block content %}
{# Include Mobile and Desktop Partials #}
{% include "v3/pages/learning/quiz/individual/session/default/_quiz_session_batch_mobile.html" %}
{% include "v3/pages/learning/quiz/individual/session/default/_quiz_session_batch_desktop.html" %}

{# Hub Modal (Shared) #}
{# Hub Modal (Shared) #}
<div id="explanation-hub-modal" class="qb-modal-overlay">
    <div class="qb-modal-container desktop:max-w-xl desktop:mx-auto desktop:h-[80vh] desktop:rounded-2xl">

        <div class="qb-hub-header">
            <h3 class="font-bold text-slate-800 text-lg">Chi tiết & Học tập</h3>
            <button id="close-hub-btn"
                class="w-8 h-8 rounded-full bg-slate-100 text-slate-600 flex items-center justify-center hover:bg-slate-200"><i
                    class="fa-solid fa-xmark"></i></button>
        </div>
        <div class="qb-hub-tabs">
            <div class="qb-hub-tab-item active" data-target="hub-expl">📖 Giải thích</div>
            <div class="qb-hub-tab-item" data-target="hub-ai">🤖 AI Coach</div>
            <div class="qb-hub-tab-item" data-target="hub-note">📝 Ghi chú</div>
        </div>
        <div class="qb-hub-content">
            <!-- Expl Tab -->
            <div id="hub-expl" class="qb-hub-pane active">
                <div class="p-4 bg-blue-50 rounded-xl border border-blue-100 text-slate-700 leading-relaxed">
                    <h4 class="font-bold text-blue-800 mb-2"><i class="fa-solid fa-circle-info"></i> Giải thích:</h4>
                    <div id="hub-explanation-text">Chưa có giải thích.</div>
                </div>
            </div>
            <!-- AI Tab -->
            <div id="hub-ai" class="qb-hub-pane">
                <div class="bg-gradient-to-r from-indigo-50 to-purple-50 p-4 rounded-xl border border-indigo-100 mb-4">
                    <div class="flex items-center justify-between mb-3">
                        <div class="flex items-center gap-2 text-indigo-700 font-bold"><i class="fa-solid fa-robot"></i>
                            <span>AI Phân Tích</span>
                        </div>
                        <button id="ai-generate-btn"
                            class="text-xs bg-white text-indigo-600 px-3 py-1.5 rounded-lg border border-indigo-200 font-semibold shadow-sm"><i
                                class="fa-solid fa-wand-magic-sparkles"></i> Tạo mới</button>
                    </div>
                    <div id="hub-ai-content"
                        class="content-display markdown-body text-sm text-slate-700 leading-relaxed min-h-[100px]">Nhấn
                        nút để yêu cầu AI phân tích...</div>
                </div>
            </div>

            <!-- Note Tab -->
            <div id="hub-note" class="qb-hub-pane">
                <div class="flex justify-between items-center mb-2">
                    <h4 class="font-bold text-slate-700">Ghi chú của bạn</h4>
                    <button id="hub-note-edit-btn"
                        class="hidden text-xs bg-blue-100 text-blue-600 border border-blue-200 px-3 py-1.5 rounded hover:bg-blue-200 font-medium"><i
                            class="fa-solid fa-pencil"></i> Sửa</button>
                </div>
                <div id="hub-note-display-mode" class="hidden">
                    <div id="hub-note-content"
                        class="content-display min-h-[100px] bg-slate-50 p-3 rounded-lg text-slate-700 whitespace-pre-wrap">
                    </div>
                </div>
                <div id="hub-note-edit-mode" class="hidden">
                    <textarea id="hub-note-input"
                        class="w-full p-3 rounded-xl border border-slate-200 text-sm bg-slate-50 focus:bg-white focus:ring-2 focus:ring-blue-200 outline-none transition"
                        rows="8" placeholder="Ghi chú của bạn..."></textarea>
                    <div class="flex justify-end mt-2 gap-2">
                        <button id="hub-note-cancel"
                            class="cm-btn bg-white hover:bg-slate-100 text-slate-600 border border-slate-300 py-1.5 px-4 text-sm rounded-md">Hủy</button>
                        <button id="hub-note-save"
                            class="cm-btn bg-blue-600 text-white hover:bg-blue-700 py-1.5 px-4 text-sm rounded-md">Lưu</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Edit Item Modal -->
<div id="edit-item-modal" class="qb-modal-overlay">
    <div class="qb-modal-container"
        style="max-width: 900px; margin: 0 auto; height: 90vh; top: 50%; bottom: auto; transform: translate(0, -50%) scale(1); border-radius: 1rem;">
        <div class="qb-hub-header">
            <h3 class="font-bold text-slate-800 text-lg"><i
                    class="fa-solid fa-pen-to-square text-blue-600 mr-2"></i>Chỉnh sửa câu hỏi</h3>
            <button id="close-edit-modal-btn"
                class="w-8 h-8 rounded-full bg-slate-100 text-slate-600 flex items-center justify-center hover:bg-slate-200"><i
                    class="fa-solid fa-xmark"></i></button>
        </div>
        <div class="flex-1 bg-slate-50 relative overflow-hidden">
            <iframe id="edit-item-iframe" src="" class="w-full h-full border-none" title="Edit Item"></iframe>
        </div>
    </div>
</div>


{# Hub Modal (Shared structure synced from Single Mode) #}
<div id="explanation-hub-modal" class="qb-modal-overlay">
    <div class="qb-modal-container desktop:max-w-xl desktop:mx-auto desktop:h-[80vh] desktop:rounded-2xl">
        <div class="qb-hub-header">
            <h3 class="font-bold text-slate-800 text-lg">Chi tiết & Học tập</h3>
            <button id="close-hub-btn"
                class="w-8 h-8 rounded-full bg-slate-100 text-slate-600 flex items-center justify-center hover:bg-slate-200"><i
                    class="fa-solid fa-xmark"></i></button>
        </div>
        <div class="qb-hub-tabs">
            <div class="qb-hub-tab-item active" data-target="hub-expl">📖 Giải thích</div>
            <div class="qb-hub-tab-item" data-target="hub-ai">🤖 AI Coach</div>
            <div class="qb-hub-tab-item" data-target="hub-note">📝 Ghi chú</div>
        </div>
        <div class="qb-hub-content">
            <!-- Expl Tab -->
            <div id="hub-expl" class="qb-hub-pane active">
                <div class="p-4 bg-blue-50 rounded-xl border border-blue-100 text-slate-700 leading-relaxed">
                    <h4 class="font-bold text-blue-800 mb-2"><i class="fa-solid fa-circle-info"></i> Giải thích:</h4>
                    <div id="hub-explanation-text">Chưa có giải thích.</div>
                </div>
            </div>
            <!-- AI Tab -->
            <div id="hub-ai" class="qb-hub-pane">
                <div class="bg-gradient-to-r from-indigo-50 to-purple-50 p-4 rounded-xl border border-indigo-100 mb-4">
                    <div class="flex items-center justify-between mb-3">
                        <div class="flex items-center gap-2 text-indigo-700 font-bold"><i class="fa-solid fa-robot"></i>
                            <span>AI Phân Tích</span>
                        </div>
                        <button id="ai-generate-btn"
                            class="text-xs bg-white text-indigo-600 px-3 py-1.5 rounded-lg border border-indigo-200 font-semibold shadow-sm"><i
                                class="fa-solid fa-wand-magic-sparkles"></i> Tạo mới</button>
                    </div>
                    <div id="hub-ai-content"
                        class="content-display markdown-body text-sm text-slate-700 leading-relaxed min-h-[100px]">Nhấn
                        nút để yêu cầu AI phân tích...</div>
                </div>
            </div>
            <!-- Note Tab -->
            <div id="hub-note" class="qb-hub-pane">
                <div class="flex justify-between items-center mb-2">
                    <h4 class="font-bold text-slate-700">Ghi chú của bạn</h4>
                    <button id="hub-note-edit-btn"
                        class="hidden text-xs bg-blue-100 text-blue-600 border border-blue-200 px-3 py-1.5 rounded hover:bg-blue-200 font-medium">
                        <i class="fa-solid fa-pencil"></i> Sửa ghi chú
                    </button>
                </div>

                <!-- Display Mode -->
                <div id="hub-note-display-mode" class="hidden">
                    <div id="hub-note-content"
                        class="content-display min-h-[100px] bg-slate-50 p-3 rounded-lg text-slate-700 whitespace-pre-wrap">
                    </div>
                </div>

                <!-- Edit Mode -->
                <div id="hub-note-edit-mode" class="hidden">
                    <textarea id="hub-note-input"
                        class="w-full p-3 rounded-xl border border-slate-200 text-sm bg-slate-50 focus:bg-white focus:ring-2 focus:ring-blue-200 outline-none transition"
                        rows="8" placeholder="Ghi chú của bạn..."></textarea>
                    <div class="flex justify-end mt-2 gap-2">
                        <button id="hub-note-cancel"
                            class="cm-btn bg-white hover:bg-slate-100 text-slate-600 border border-slate-300 py-1.5 px-4 text-sm rounded-md">Hủy</button>
                        <button id="hub-note-save"
                            class="cm-btn bg-blue-600 text-white hover:bg-blue-700 py-1.5 px-4 text-sm rounded-md">Lưu
                            ghi chú</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Feedback Modal -->
<div id="feedback-modal" class="qb-modal-overlay">
    <div class="qb-modal-container"
        style="max-width: 500px; margin: 0 auto; height: auto; top: 50%; bottom: auto; transform: translate(0, -50%) scale(1); border-radius: 1rem;">
        <div class="qb-hub-header">
            <h3 class="font-bold text-slate-800 text-lg"><i class="fa-solid fa-flag text-red-500 mr-2"></i>Báo lỗi / Góp
                ý</h3>
            <button id="close-feedback-btn"
                class="w-8 h-8 rounded-full bg-slate-100 text-slate-600 flex items-center justify-center hover:bg-slate-200"><i
                    class="fa-solid fa-xmark"></i></button>
        </div>
        <div class="p-4">
            <p class="text-sm text-slate-600 mb-3">Hãy mô tả vấn đề bạn gặp phải với câu hỏi này. Đóng góp của bạn giúp
                chúng tôi cải thiện chất lượng!</p>
            <textarea id="feedback-input"
                class="w-full p-3 rounded-xl border border-slate-200 text-sm bg-slate-50 focus:bg-white focus:ring-2 focus:ring-blue-200 outline-none transition mb-4"
                rows="4" placeholder="Nhập nội dung phản hồi..."></textarea>
            <div class="flex justify-end gap-2">
                <button id="feedback-cancel-btn"
                    class="cm-btn bg-white hover:bg-slate-100 text-slate-600 border border-slate-300 py-2 px-4 text-sm rounded-lg">Hủy</button>
                <button id="feedback-submit-btn"
                    class="cm-btn bg-blue-600 text-white hover:bg-blue-700 py-2 px-4 text-sm rounded-lg">Gửi phản
                    hồi</button>
            </div>
        </div>
    </div>
</div>

<!-- Transcript Modal -->
<div id="transcript-modal" class="fixed inset-0 z-50 flex items-center justify-center hidden"
    aria-labelledby="modal-title" role="dialog" aria-modal="true">
    <div class="fixed inset-0 bg-gray-500 bg-opacity-75 transition-opacity backdrop-blur-sm"
        id="transcript-modal-backdrop"></div>

    <div
        class="relative bg-white rounded-xl shadow-2xl transform transition-all sm:my-8 sm:w-full sm:max-w-xl mx-4 overflow-hidden flex flex-col max-h-[90vh]">
        {# Modal Header #}
        <div class="bg-slate-50 px-6 py-4 border-b border-slate-100 flex items-center justify-between shadow-sm z-10">
            <h3 class="text-lg leading-6 font-bold text-slate-800 flex items-center gap-2" id="modal-title">
                <i class="fa-solid fa-file-audio text-blue-600"></i>
                Transcript
            </h3>
            <button type="button" id="close-transcript-modal"
                class="text-slate-400 hover:text-slate-600 transition focus:outline-none">
                <i class="fa-solid fa-xmark text-xl"></i>
            </button>
        </div>

        {# Modal Body #}
        <div class="px-6 py-6 overflow-y-auto flex-1 bg-white relative">

            <div id="transcript-loading"
                class="absolute inset-0 bg-white/90 z-20 flex flex-col items-center justify-center text-blue-600 hidden">
                <i class="fas fa-spinner fa-spin text-3xl mb-3"></i>
                <p class="font-medium animate-pulse">Đang chuyển đổi giọng nói thành văn bản...</p>
                <p class="text-xs text-slate-400 mt-2">Việc này có thể mất vài giây với audio dài.</p>
            </div>

            <!-- View Mode -->
            <div id="transcript-content"
                class="text-slate-700 text-base leading-relaxed whitespace-pre-wrap font-serif">
                <!-- Content will be injected here -->
            </div>

            <!-- Edit Mode -->
            <div id="transcript-edit-container" class="hidden">
                <textarea id="transcript-editor"
                    class="w-full h-64 p-3 border border-slate-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 font-serif text-base leading-relaxed"
                    placeholder="Nhập nội dung transcript..."></textarea>
            </div>

            <div id="transcript-empty" class="hidden text-center py-8 text-slate-400 flex flex-col items-center">
                <i class="fas fa-quote-right text-4xl mb-3 opacity-20"></i>
                <p>Chưa có nội dung transcript.</p>
            </div>

            <div id="transcript-error"
                class="hidden bg-red-50 text-red-700 p-4 rounded-lg flex items-start gap-3 border border-red-100">
                <i class="fas fa-exclamation-circle mt-0.5 shrink-0"></i>
                <div>
                    <h4 class="font-bold text-sm">Không thể lấy transcript</h4>
                    <p class="text-sm mt-1" id="transcript-error-msg">Lỗi kết nối.</p>
                </div>
            </div>
        </div>

        {# Modal Footer with Actions #}
        <div class="px-6 py-4 border-t border-slate-100 bg-slate-50 flex justify-between items-center rounded-b-2xl">
            <!-- Left: Status/Info -->
            <div class="text-xs text-slate-400 italic">
                AI Speech-to-Text
            </div>

            <!-- Right: Buttons -->
            <div class="flex items-center gap-2">
                <button type="button" id="transcript-edit-btn"
                    class="hidden text-blue-600 hover:text-blue-700 px-3 py-1.5 text-sm font-medium transition">
                    <i class="fas fa-pen mr-1"></i> Sửa
                </button>

                <div id="transcript-edit-actions" class="hidden flex items-center gap-2">
                    <button type="button" id="transcript-cancel-btn"
                        class="text-slate-500 hover:text-slate-700 px-3 py-1.5 text-sm font-medium transition">
                        Hủy
                    </button>
                    <button type="button" id="transcript-save-btn"
                        class="bg-blue-600 text-white hover:bg-blue-700 px-4 py-1.5 rounded-lg text-sm font-medium transition shadow-sm">
                        Lưu
                    </button>
                </div>

                <button type="button" onclick="document.getElementById('transcript-modal').classList.add('hidden')"
                    class="text-slate-500 hover:text-slate-700 px-4 py-2 rounded-lg transition"
                    id="transcript-close-main-btn">
                    Đóng
                </button>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
{{ super() }}
<script>
    // === DUAL RENDERING UPDATE HELPER ===
    const setText = (selector, text) => document.querySelectorAll(selector).forEach(el => el.textContent = text);
    const setHtml = (selector, html) => document.querySelectorAll(selector).forEach(el => el.innerHTML = html);
    const toggleClass = (selector, cls, force) => document.querySelectorAll(selector).forEach(el => el.classList.toggle(cls, force));
    const setStyle = (selector, prop, val) => document.querySelectorAll(selector).forEach(el => el.style[prop] = val);
    const setAttr = (selector, attr, val) => document.querySelectorAll(selector).forEach(el => el.setAttribute(attr, val));

    // --- Global State ---
    let currentQuestionBatch = [];
    let currentBatchMeta = { startIndex: 0, totalItemsInSession: 0 };
    let userAnswers = {};
    let isBatchSubmitted = false;
    let totalQuestionsInSession = 0;
    let sessionTotalAnswered = 0;
    let activeHubItemId = null; // Currently tracked question ID
    let activeFeedbackItemId = null;
    const SESSION_KEY = 'quiz_session_batch_state';

    // URLs
    const getQuestionBatchUrl = "{{ url_for('learning.quiz_learning.get_question_batch') }}";
    const submitAnswerBatchUrl = "{{ url_for('learning.quiz_learning.submit_answer_batch') }}";
    const endSessionUrl = "{{ url_for('learning.quiz_learning.end_session') }}";
    const getAiResponseUrl = "{{ url_for('ai_services.get_ai_response') }}";
    const saveNoteUrlTemplate = "{{ url_for('notes.save_note', item_id=0) }}";
    const transcriptUrlTemplate = "{{ url_for('learning.quiz_learning.get_quiz_transcript', item_id=0) }}";
    const quizDashboardUrl = "{{ url_for('learning.quiz_learning.quiz_learning_dashboard') }}";
    const csrfToken = document.querySelector('meta[name="csrf-token"]')?.getAttribute('content') || '';
    const csrfHeaders = csrfToken ? { 'X-CSRFToken': csrfToken } : {};

    // --- Init ---
    document.addEventListener('DOMContentLoaded', init);
    window.addEventListener('scroll', handleScroll);

    function init() {
        loadQuizTitleFromStorage();
        if (!loadState()) {
            getNextQuestionBatch();
        }
    }

    function loadQuizTitleFromStorage() {
        try {
            // Title
            const storedTitles = localStorage.getItem('selectedQuizSetTitles');
            if (storedTitles) {
                const titles = JSON.parse(storedTitles);
                const titleString = Object.values(titles).join(', ');
                if (titleString) {
                    setText('.js-quiz-set-title', titleString); // Full title, no truncation
                }
            }
            // Mode Label - Static as per user request
            setText('.js-quiz-mode-label', "QUIZ INDIVIDUAL BATCH");
        } catch (e) {
            console.error('Error loading titles', e);
        }
    }

    function getModeNameFromStorage() {
        // Simple mapping based on potentially stored mode ID or infer from URL if possible
        // Ideally we pass this from backend, but for now let's try to parse from URL or default
        const urlParams = new URLSearchParams(window.location.search);
        // If needed, we can store selectedModeName in localStorage in dashboard like we do for titles
        // For now, let's map common IDs if known, or return "Luyện tập"
        // Let's check if we can get it from the URL segment if it's there
        return "Luyện tập"; // Placeholder or enhance
        // Better: Update dashboard to save mode name!
    }

    // --- State Management ---
    function saveState() {
        const state = {
            currentQuestionBatch,
            currentBatchMeta,
            userAnswers,
            isBatchSubmitted,
            totalQuestionsInSession,
            sessionTotalAnswered
        };
        try {
            sessionStorage.setItem(SESSION_KEY, JSON.stringify(state));
        } catch (e) { console.error('Error saving state', e); }
    }

    function loadState() {
        try {
            const raw = sessionStorage.getItem(SESSION_KEY);
            if (!raw) return false;
            const state = JSON.parse(raw);

            // Validate basic integrity
            if (!state.currentQuestionBatch || !Array.isArray(state.currentQuestionBatch) || state.currentQuestionBatch.length === 0) {
                return false;
            }

            // Restore
            currentQuestionBatch = state.currentQuestionBatch;
            currentBatchMeta = state.currentBatchMeta || {};
            userAnswers = state.userAnswers || {};
            isBatchSubmitted = state.isBatchSubmitted || false;
            totalQuestionsInSession = state.totalQuestionsInSession || 0;
            sessionTotalAnswered = state.sessionTotalAnswered || 0;

            restoreUI();
            return true;
        } catch (e) {
            console.error('Error loading state', e);
            clearState();
            return false;
        }
    }

    function clearState() {
        sessionStorage.removeItem(SESSION_KEY);
    }

    function restoreUI() {
        // Construct a batchData-like object to reuse display logic
        // We only need basic fields for displayQuestionBatch to run
        const batchData = {
            items: currentQuestionBatch,
            start_index: currentBatchMeta.startIndex,
            total_items_in_session: currentBatchMeta.totalItemsInSession,
            // These might be stale but displayQuestionBatch recalculates or we override below
            session_correct_answers: 0, // Placeholder, will update later
            session_total_answered: sessionTotalAnswered
        };

        displayQuestionBatch(batchData, true); // true = restoring

        // Restore Selections
        Object.entries(userAnswers).forEach(([itemId, answer]) => {
            const qId = parseInt(itemId);
            document.querySelectorAll(`.option-button[data-question-id="${qId}"]`).forEach(b => b.classList.remove('selected'));
            document.querySelectorAll(`.option-button[data-question-id="${qId}"][data-option="${answer}"]`).forEach(b => b.classList.add('selected'));
        });

        // Restore Feedback if submitted
        if (isBatchSubmitted) {
            toggleControlButtons('submitted');
            currentQuestionBatch.forEach(q => {
                renderFeedbackForQuestion(q); // Helper to render feedback
            });
            // Reveal all hints/explanations after submission
            document.querySelectorAll('.js-hint-btn').forEach(btn => btn.classList.remove('hidden'));
            document.querySelectorAll('.js-batch-explain-btn').forEach(btn => btn.classList.remove('hidden'));
        }
    }

    function renderFeedbackForQuestion(result) {
        const questionCards = document.querySelectorAll(`.question-card[data-item-id="${result.item_id}"]`);
        questionCards.forEach(card => {
            const feedbackArea = card.querySelector('.feedback-area');
            let feedbackHtml = result.is_correct ?
                `<div class="feedback-box feedback-correct"><span class="feedback-icon"><i class="fas fa-check-circle"></i></span><div class="feedback-text"><strong>Chính xác!</strong></div></div>` :
                `<div class="feedback-box feedback-incorrect"><span class="feedback-icon"><i class="fas fa-times-circle"></i></span><div class="feedback-text"><strong>Sai rồi</strong><span>Đáp án đúng: ${result.correct_answer}</span></div></div>`;

            // Standard Feedback Area (Just correct/incorrect + optional base explanation text if we want duplicates?)
            // We already have detailed explanation in the insights section.
            // Let's keep the base feedback minimal or redundant?
            // User requested "Chi tiết & Học tập".
            // The Insights section handles the detailed explanation.
            // We can just set the Feedback Box here.

            feedbackArea.innerHTML = feedbackHtml;
            card.querySelectorAll('.option-button').forEach(btn => {
                btn.classList.remove('selected');
                const opt = btn.dataset.option;
                if (opt === result.correct_answer) btn.classList.add('correct');
                else if (opt === userAnswers[result.item_id] && !result.is_correct) btn.classList.add('incorrect');
                btn.style.pointerEvents = 'none';
            });

            // Reveal Insights Section
            const insightsDiv = document.getElementById(`insights-${result.item_id}`);
            if (insightsDiv) insightsDiv.classList.remove('hidden');
        });
    }

    // --- Functions ---
    const numberFormatter = new Intl.NumberFormat('vi-VN');
    const percentageFormatter = new Intl.NumberFormat('vi-VN', { maximumFractionDigits: 1, minimumFractionDigits: 0 });

    function updateProgressCard() {
        const totalInSession = Number(totalQuestionsInSession) || 0;
        const answered = Number(sessionTotalAnswered) || 0;
        const hasTotal = totalInSession > 0;

        if (hasTotal) {
            const cappedAnswered = Math.min(answered, totalInSession);
            setText('.js-quiz-total-label', `${numberFormatter.format(cappedAnswered)} / ${numberFormatter.format(totalInSession)}`);
        } else {
            setText('.js-quiz-total-label', numberFormatter.format(answered));
        }

        if (hasTotal) {
            const remaining = Math.max(totalInSession - answered, 0);
            setText('.js-quiz-remaining-label', numberFormatter.format(remaining));
        } else {
            setText('.js-quiz-remaining-label', '--');
        }

        const progressWidth = hasTotal ? Math.min((answered / totalInSession) * 100, 100) : 0;
        setStyle('.js-quiz-progress-fill', 'width', `${progressWidth}%`);
    }

    function updateSessionSummary(correct = 0, total = 0) {
        const safeTotal = Number(total) || 0;
        const safeCorrect = Number(correct) || 0;
        sessionTotalAnswered = safeTotal;
        setText('.js-session-total-count', numberFormatter.format(safeTotal));
        setText('.js-session-correct-count', numberFormatter.format(safeCorrect));
        const accuracy = safeTotal > 0 ? (safeCorrect / safeTotal) * 100 : 0;
        setText('.js-session-accuracy', `${percentageFormatter.format(accuracy)}%`);
        updateProgressCard();
    }

    async function getNextQuestionBatch() {
        setHtml('.js-quiz-content', `<div class="flex flex-col items-center justify-center h-full text-blue-500 min-h-[300px]"><i class="fas fa-spinner fa-spin text-4xl mb-3"></i><p>Đang tải câu hỏi...</p></div>`);
        toggleControlButtons('loading');

        try {
            const response = await fetch(getQuestionBatchUrl, { headers: { 'X-Requested-With': 'XMLHttpRequest' } });
            if (!response.ok) {
                if (response.status === 404) {
                    handleSessionComplete(await response.json());
                    return;
                }
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const batchData = await response.json();

            // Reset state for new batch
            userAnswers = {};
            isBatchSubmitted = false;

            displayQuestionBatch(batchData);
            saveState();
        }
        catch (error) {
            console.error('Lỗi khi tải nhóm câu hỏi:', error);
            setHtml('.js-quiz-content', `<p class="text-red-500 text-center p-4">Không thể tải câu hỏi. Vui lòng thử lại.</p>`);
            toggleControlButtons('error');
        }
    }

    function displayQuestionBatch(batchData, isRestoring = false) {
        if (!isRestoring) {
            currentQuestionBatch = batchData.items;
            currentBatchMeta = {
                startIndex: batchData.start_index || 0,
                totalItemsInSession: batchData.total_items_in_session || batchData.items.length
            };
            const totalGroupsFallback = batchData.total_question_groups_in_session || currentBatchMeta.totalItemsInSession;
            totalQuestionsInSession = Number(totalGroupsFallback) || currentQuestionBatch.length;
        }

        updateSessionSummary(batchData.session_correct_answers, batchData.session_total_answered);

        // Render HTML
        const fullBatchContentHtml = currentQuestionBatch
            .map((questionData, index) => buildQuestionCardHtml(questionData, index))
            .join('');

        setHtml('.js-quiz-content', fullBatchContentHtml);

        const startRange = batchData.question_number_min || (currentBatchMeta.startIndex + 1);
        const endRange = batchData.question_number_max || (currentBatchMeta.startIndex + currentQuestionBatch.length);
        const totalInSession = totalQuestionsInSession;
        setText('.js-quiz-group-range', totalInSession ? `Câu ${startRange}-${endRange}` : '---');

        updateProgressCard();
        attachOptionHandlers();
        if (!isRestoring) toggleControlButtons('answering');

        renderQuickNav();
        checkCompletionStatus(); // Validate initially (likely disabled)

        // Allow DOM to settle then trigger scroll check
        setTimeout(handleScroll, 500);
    }

    function renderQuickNav() {
        const container = document.getElementById('batch-quick-nav-content');
        if (!container) return;

        const navHtml = currentQuestionBatch.map((q, idx) => {
            const num = (currentBatchMeta.startIndex || 0) + idx + 1;
            const isAnswered = userAnswers.hasOwnProperty(q.item_id);
            let statusClass = '';

            if (isAnswered) {
                statusClass = 'answered';
                if (isBatchSubmitted) {
                    if (q.is_correct) statusClass += ' correct';
                    else statusClass += ' incorrect';
                }
            }
            return `<div class="qb-nav-item ${statusClass}" data-index="${idx}">${num}</div>`;
        }).join('');

        container.innerHTML = navHtml;

        // Attach click handlers
        container.querySelectorAll('.qb-nav-item').forEach(item => {
            item.addEventListener('click', () => {
                const idx = parseInt(item.dataset.index);
                const card = document.querySelectorAll('.question-card')[idx];
                if (card) {
                    // Mobile header offset approx 130px now with 2 rows
                    const offset = 140;
                    const bodyRect = document.body.getBoundingClientRect().top;
                    const elementRect = card.getBoundingClientRect().top;
                    const elementPosition = elementRect - bodyRect;
                    const offsetPosition = elementPosition - offset;

                    window.scrollTo({
                        top: offsetPosition,
                        behavior: 'smooth'
                    });

                    // Update active state manually
                    container.querySelectorAll('.qb-nav-item').forEach(el => el.classList.remove('active'));
                    item.classList.add('active');

                    // Center the clicked item in scroll view
                    item.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
                }
            });
        });

        // Scroll Buttons Logic
        const leftBtn = document.getElementById('quick-nav-left');
        const rightBtn = document.getElementById('quick-nav-right');
        const scrollAmount = 150;

        if (leftBtn && rightBtn) {
            leftBtn.addEventListener('click', () => {
                container.scrollBy({ left: -scrollAmount, behavior: 'smooth' });
            });
            rightBtn.addEventListener('click', () => {
                container.scrollBy({ left: scrollAmount, behavior: 'smooth' });
            });
        }
    }

    function buildQuestionCardHtml(questionData, index) {
        const questionNumber = questionData.display_number || ((currentBatchMeta.startIndex || 0) + index + 1);
        const content = questionData.content || {};

        // Build Options
        let optionsHtml = '';
        const options = content.options || {};
        ['A', 'B', 'C', 'D'].forEach(key => {
            if (options[key]) {
                optionsHtml += `
                        <button class="option-button" data-question-id="${questionData.item_id}" data-option="${key}">
                            <span>${key}</span> <span>${formatTextForHtml(options[key])}</span>
                        </button>`;
            }
        });

        // Build Media
        let mediaHtml = '';
        if (content.question_image_file) {
            mediaHtml += `<img src="${content.question_image_file}" alt="Hình ảnh" class="quiz-image mb-4">`;
        }
        if (content.question_audio_file) {
            mediaHtml += `<audio controls src="${content.question_audio_file}" class="w-full mb-2"></audio>`;
        }

        // Action Buttons Group (Edit, Transcript, Report)
        let actionButtonsHtml = '';

        // 1. Edit Button (Orange) - Check if editable
        if (questionData.can_edit) {
            actionButtonsHtml += `
            <button class="w-8 h-8 flex items-center justify-center text-orange-500 hover:text-orange-600 transition-colors js-edit-question-btn"
                    data-question-id="${questionData.item_id}" 
                    data-container-id="${questionData.container_id}"
                    title="Cập nhật">
                <i class="fa-solid fa-pen-to-square text-lg"></i>
            </button>
        `;
        }

        // 2. Transcript Button (Blue) - Check multiple audio sources
        const hasAudio = (content.question_audio_file) || (questionData.question_audio) || (questionData.audio_url);

        if (hasAudio) {
            actionButtonsHtml += `
                <button class="w-8 h-8 flex items-center justify-center text-slate-400 hover:text-blue-600 transition-colors js-open-transcript-btn" 
                    data-item-id="${questionData.item_id}"
                    title="Nội dung nghe">
                    <i class="fa-solid fa-file-lines text-lg"></i>
                </button>`;
        }

        // 3. Report Button (Grey)
        actionButtonsHtml += `
            <button class="w-8 h-8 flex items-center justify-center text-slate-400 hover:text-red-500 transition-colors js-report-error-btn"
                    data-question-id="${questionData.item_id}" title="Báo lỗi">
                <i class="fa-regular fa-flag text-lg"></i>
            </button>
        `;

        // 4. Hint Button (Yellow)
        // Keep hidden by default unless logic requires it
        actionButtonsHtml += `
            <button class="w-8 h-8 flex items-center justify-center text-yellow-500 hover:text-yellow-600 transition-colors js-hint-btn hidden"
                    data-question-id="${questionData.item_id}" title="Gợi ý">
                <i class="fa-regular fa-lightbulb text-lg"></i>
            </button>
        `;

        return `
                <div class="question-card" data-item-id="${questionData.item_id}">
                    <div class="flex justify-between items-center text-sm font-bold text-slate-500 uppercase tracking-wider mb-2">
                        <span>Câu ${questionNumber}</span>
                        <div class="flex items-center gap-1">
                            ${actionButtonsHtml}
                        </div>
                    </div>
                    <h2 class="text-xl font-bold text-slate-900 mb-4">${formatTextForHtml(content.question)}</h2>
                    ${mediaHtml}
                    <div class="options-container">${optionsHtml}</div>
                    <div class="feedback-area mt-4"></div>
                </div>
            `;
    }

    function attachOptionHandlers() {
        document.querySelectorAll('.option-button').forEach(button => {
            button.removeEventListener('click', handleOptionClick);
            button.addEventListener('click', handleOptionClick);
        });
        // Desktop/Inline Hub Buttons
        document.querySelectorAll('.js-open-hub-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const itemId = e.currentTarget.dataset.itemId;
                openHub(itemId);
            });
        });
        // Transcript Buttons
        document.querySelectorAll('.js-open-transcript-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const itemId = e.currentTarget.dataset.itemId;
                openTranscript(itemId);
            });
        });
        // Edit Question Buttons (via Modal)
        document.querySelectorAll('.js-edit-question-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.preventDefault();
                const qId = btn.dataset.questionId;
                const containerId = btn.dataset.containerId;

                if (qId && containerId) {
                    const editUrl = `/content/quizzes/${containerId}/items/edit/${qId}`;
                    if (window.openEditModal) window.openEditModal(editUrl, qId);
                } else {
                    showCustomAlert("Thiếu thông tin để sửa câu hỏi.", "error");
                }
            });
        });

        // Report Buttons
        document.querySelectorAll('.js-report-error-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const itemId = e.currentTarget.dataset.questionId;
                activeFeedbackItemId = itemId;
                const modal = document.getElementById('feedback-modal');
                const input = document.getElementById('feedback-input');
                if (modal && input) {
                    input.value = '';
                    modal.classList.add('open');
                }
            });
        });

        // Feedback Buttons
        document.querySelectorAll('.js-feedback-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const itemId = e.currentTarget.dataset.itemId;
                activeFeedbackItemId = itemId;
                const modal = document.getElementById('feedback-modal');
                const input = document.getElementById('feedback-input');
                if (modal && input) {
                    input.value = ''; // Reset input
                    modal.classList.add('open');
                }
            });
        });
        // Mobile Bottom Hub Button
        document.querySelectorAll('.js-mobile-hub-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                if (activeHubItemId) openHub(activeHubItemId);
                else showCustomAlert("Hãy cuộn tới một câu hỏi.", "info");
            });
        });

        // Lightbulb Button (Open Hub Modal)
        document.querySelectorAll('.js-hint-btn').forEach(btn => {
            btn.classList.remove('hidden'); // Ensure visible
            btn.addEventListener('click', (e) => {
                const itemId = e.currentTarget.dataset.questionId;
                if (itemId) openHub(itemId);
            });
        });

        attachInsightsHandlers(); // Attach handlers for AI and Notes
    }

    function attachInsightsHandlers() {
        // AI Generate
        document.querySelectorAll('.js-ai-gen-btn').forEach(btn => {
            btn.removeEventListener('click', handleBatchAiGenerate); // Prevent duplicates
            btn.addEventListener('click', handleBatchAiGenerate);
        });

        // Note Edit Switch
        document.querySelectorAll('.js-note-edit-switch-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const id = e.currentTarget.dataset.id;
                document.getElementById(`note-display-${id}`).classList.add('hidden');
                document.getElementById(`note-edit-${id}`).classList.remove('hidden');
                e.currentTarget.classList.add('hidden');
            });
        });

        // Note Cancel
        document.querySelectorAll('.js-note-cancel-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const id = e.currentTarget.dataset.id;
                const displayDiv = document.getElementById(`note-display-${id}`);
                const editDiv = document.getElementById(`note-edit-${id}`);
                const editSwitchBtn = document.querySelector(`.js-note-edit-switch-btn[data-id="${id}"]`);

                // Revert
                displayDiv.classList.remove('hidden');
                editDiv.classList.add('hidden');
                if (editSwitchBtn) editSwitchBtn.classList.remove('hidden');
            });
        });

        // Note Save
        document.querySelectorAll('.js-note-save-btn').forEach(btn => {
            btn.removeEventListener('click', handleBatchNoteSave);
            btn.addEventListener('click', handleBatchNoteSave);
        });
    }

    async function handleBatchAiGenerate(e) {
        const btn = e.currentTarget;
        const itemId = btn.dataset.id;
        const contentDiv = document.getElementById(`ai-content-${itemId}`);

        if (!itemId) return;

        btn.disabled = true;
        btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
        const failContent = '<span class="text-red-500 text-xs">Lỗi tải AI.</span>';

        try {
            const res = await fetch(getAiResponseUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken },
                body: JSON.stringify({ item_id: itemId, prompt_type: 'explanation' })
            });
            const data = await res.json();
            const content = data.html_content || data.response;

            if (contentDiv) contentDiv.innerHTML = content;

            // Update Local State
            const qIdx = currentQuestionBatch.findIndex(q => q.item_id == itemId);
            if (qIdx !== -1) {
                currentQuestionBatch[qIdx].ai_explanation = content;
                saveState();
            }

            btn.classList.add('hidden'); // Hide button on success
        } catch (err) {
            console.error(err);
            if (contentDiv) contentDiv.innerHTML = failContent;
            btn.innerHTML = '<i class="fa-solid fa-rotate-right"></i> Thử lại';
            btn.disabled = false;
        }
    }

    async function handleBatchNoteSave(e) {
        const btn = e.currentTarget;
        const itemId = btn.dataset.id;
        const input = document.getElementById(`note-input-${itemId}`);
        const displayDiv = document.getElementById(`note-display-${itemId}`);
        const itemContainer = document.querySelector(`.question-card[data-item-id="${itemId}"]`); // Context

        if (!input) return;
        const content = input.value;
        const originalText = btn.innerHTML;

        btn.disabled = true;
        btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';

        try {
            await fetch(saveNoteUrlTemplate.replace('0', itemId), {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken },
                body: JSON.stringify({ content })
            });

            // Update UI
            if (displayDiv) {
                displayDiv.textContent = content;
                displayDiv.classList.remove('hidden');
            }

            // Hide edit mode
            document.getElementById(`note-edit-${itemId}`)?.classList.add('hidden');
            const editSwitchBtn = itemContainer.querySelector('.js-note-edit-switch-btn');
            if (editSwitchBtn) editSwitchBtn.classList.remove('hidden');

            // Update State
            const qIdx = currentQuestionBatch.findIndex(q => q.item_id == itemId);
            if (qIdx !== -1) {
                currentQuestionBatch[qIdx].note_content = content;
                saveState();
            }
            showCustomAlert("Đã lưu ghi chú.", "success");

        } catch (err) {
            console.error(err);
            showCustomAlert("Lỗi lưu ghi chú.", "error");
        } finally {
            btn.innerHTML = originalText;
            btn.disabled = false;
        }
    }

    function handleOptionClick(e) {
        if (isBatchSubmitted) return;
        const btn = e.currentTarget;
        const questionId = btn.dataset.questionId;
        const selectedOption = btn.dataset.option;
        userAnswers[questionId] = selectedOption;
        document.querySelectorAll(`.option-button[data-question-id="${questionId}"]`).forEach(b => b.classList.remove('selected'));
        document.querySelectorAll(`.option-button[data-question-id="${questionId}"][data-option="${selectedOption}"]`).forEach(b => b.classList.add('selected'));
        saveState();
        updateQuickNavState(questionId);
        checkCompletionStatus();
    }

    function updateQuickNavState(questionId) {
        // Find index of question
        const idx = currentQuestionBatch.findIndex(q => q.item_id == questionId);
        if (idx !== -1) {
            const navItem = document.querySelector(`.qb-nav-item[data-index="${idx}"]`);
            if (navItem) navItem.classList.add('answered');
        }
    }

    function checkCompletionStatus() {
        if (isBatchSubmitted) return;
        const allAnswered = currentQuestionBatch.every(q => userAnswers.hasOwnProperty(q.item_id));
        const submits = document.querySelectorAll('.js-submit-batch-btn');
        if (allAnswered) {
            submits.forEach(btn => {
                btn.style.opacity = '1';
                btn.classList.remove('opacity-50', 'cursor-not-allowed');
                // Optional: visual pulse or highlight
            });
        } else {
            submits.forEach(btn => {
                btn.style.opacity = '0.5';
                btn.classList.add('opacity-50');
            });
        }
    }

    async function submitAnswerBatch() {
        if (isBatchSubmitted) return;
        const allAnswered = currentQuestionBatch.every(q => userAnswers.hasOwnProperty(q.item_id));
        if (!allAnswered) {
            showCustomAlert("Vui lòng trả lời tất cả các câu hỏi.");
            return;
        }

        isBatchSubmitted = true;
        toggleControlButtons('submitting');
        const answersToSend = Object.keys(userAnswers).map(itemId => ({ item_id: parseInt(itemId), user_answer: userAnswers[itemId] }));

        try {
            const response = await fetch(submitAnswerBatchUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', ...csrfHeaders },
                body: JSON.stringify({ answers: answersToSend })
            });
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            const responseData = await response.json();

            // Process Results
            responseData.results.forEach(result => {
                // Update Local data
                const qIndex = currentQuestionBatch.findIndex(q => q.item_id === result.item_id);
                if (qIndex !== -1) {
                    currentQuestionBatch[qIndex].explanation = result.explanation;
                    currentQuestionBatch[qIndex].correct_answer = result.correct_answer;
                    currentQuestionBatch[qIndex].is_correct = result.is_correct;
                }
                renderFeedbackForQuestion(result);
            });
            updateSessionSummary(responseData.session_correct_answers, responseData.session_total_answered);
            toggleControlButtons('submitted');
            saveState();

        } catch (error) {
            console.error(error);
            showCustomAlert('Có lỗi xảy ra khi gửi đáp án.');
            isBatchSubmitted = false;
            toggleControlButtons('answering');
        }
    }

    // === SCROLL TRACKING LOGIC ===
    function handleScroll() {
        // Check visible cards
        // Only effective on mobile view generally, but works for desktop too if needed.
        // Logic: Find the card that takes up the most screen space or is closest to center.
        let maxVisibility = 0;
        let bestCardId = null;

        // Only target visible question cards (in case of desktop/mobile hidden logic, though usually matched classes handle it)
        // But due to dual rendering, we have duplicated cards. We need to check only the currently visible ones.
        // On mobile, .lg:hidden block is visible. On desktop .hidden.lg:block is visible.
        // Since IntersectionObserver/getBoundingClientRect works on actual layout:

        const cards = document.querySelectorAll('.question-card');

        cards.forEach(card => {
            const rect = card.getBoundingClientRect();
            const viewHeight = window.innerHeight;

            // Calculate intersection height
            const intersectTop = Math.max(0, rect.top);
            const intersectBottom = Math.min(viewHeight, rect.bottom);
            const intersectHeight = Math.max(0, intersectBottom - intersectTop);

            if (intersectHeight > maxVisibility) {
                maxVisibility = intersectHeight;
                bestCardId = card.dataset.itemId;
            }
        });

        if (bestCardId && bestCardId !== activeHubItemId) {
            activeHubItemId = bestCardId;
            // Highlight active card? Not necessary requested but good for debug
            // Enable/Update the sticky button context
        }
    }


    // === HUB LOGIC ===
    const dom = {
        hubModal: document.getElementById('explanation-hub-modal'),
        closeHubBtn: document.getElementById('close-hub-btn'),
        hubExplText: document.getElementById('hub-explanation-text'),
        hubAiContent: document.getElementById('hub-ai-content'),
        aiGenerateBtn: document.getElementById('ai-generate-btn'),
        hubNoteInput: document.getElementById('hub-note-input'),
        hubNoteSave: document.getElementById('hub-note-save'),
        hubNoteEditBtn: document.getElementById('hub-note-edit-btn'),
        hubNoteCancelBtn: document.getElementById('hub-note-cancel'),
        hubNoteDisplay: document.getElementById('hub-note-display-mode'),
        hubNoteEdit: document.getElementById('hub-note-edit-mode'),
        hubNoteContent: document.getElementById('hub-note-content'),
        // Transcript Elements
        // Transcript Modal Elements
        transcriptModal: document.getElementById('transcript-modal'),
        transcriptContent: document.getElementById('transcript-content'),
        transcriptLoading: document.getElementById('transcript-loading'),
        transcriptError: document.getElementById('transcript-error'),
        transcriptEmpty: document.getElementById('transcript-empty'),
        transcriptEditContainer: document.getElementById('transcript-edit-container'),
        transcriptEditor: document.getElementById('transcript-editor'),
        transcriptEditBtn: document.getElementById('transcript-edit-btn'),
        transcriptEditActions: document.getElementById('transcript-edit-actions'),
        transcriptSaveBtn: document.getElementById('transcript-save-btn'),
        transcriptCancelBtn: document.getElementById('transcript-cancel-btn'),

        // Hub Refs
        hubModal: document.getElementById('explanation-hub-modal'),
        hubExplText: document.getElementById('hub-explanation-text'),
        hubAiContent: document.getElementById('hub-ai-content'),
        hubNoteDisplay: document.getElementById('hub-note-display-mode'),
        hubNoteEdit: document.getElementById('hub-note-edit-mode'),
        hubNoteEditBtn: document.getElementById('hub-note-edit-btn'),
        hubNoteContent: document.getElementById('hub-note-content'),
        hubNoteInput: document.getElementById('hub-note-input'),
        closeHubBtn: document.getElementById('close-hub-btn'),
        aiGenerateBtn: document.getElementById('ai-generate-btn')
    };

    function openHub(itemId) {
        const questionData = currentQuestionBatch.find(q => q.item_id == itemId);
        if (!questionData) return;
        activeHubItemId = itemId;

        // Populate Hub
        if (questionData.explanation) {
            dom.hubExplText.innerHTML = formatTextForHtml(questionData.explanation);
        } else if (isBatchSubmitted) {
            dom.hubExplText.innerHTML = "Chưa có giải thích cho câu hỏi này.";
        } else {
            dom.hubExplText.innerHTML = "Hãy hoàn thành câu hỏi để xem giải thích.";
        }

        if (questionData.ai_explanation) {
            dom.hubAiContent.innerHTML = questionData.ai_explanation;
        } else {
            dom.hubAiContent.innerHTML = "Nhấn nút để yêu cầu AI phân tích...";
        }

        updateNoteUI(questionData.note_content || "");

        dom.hubModal.classList.add('open');
    }

    function updateNoteUI(content) {
        if (content && content.trim()) {
            dom.hubNoteDisplay.classList.remove('hidden');
            dom.hubNoteEdit.classList.add('hidden');
            dom.hubNoteEditBtn.classList.remove('hidden');
            dom.hubNoteContent.textContent = content;
            dom.hubNoteInput.value = content;
        } else {
            dom.hubNoteDisplay.classList.add('hidden');
            dom.hubNoteEdit.classList.remove('hidden');
            dom.hubNoteEditBtn.classList.add('hidden');
            dom.hubNoteInput.value = '';
        }
    }

    // Hub Listeners
    dom.closeHubBtn.addEventListener('click', () => dom.hubModal.classList.remove('open'));

    // Close Hub when clicking outside content (on the overlay)
    dom.hubModal.addEventListener('click', (e) => {
        if (e.target === dom.hubModal) {
            dom.hubModal.classList.remove('open');
        }
    });

    document.querySelectorAll('.qb-hub-tab-item').forEach(tab => {
        tab.addEventListener('click', () => {
            document.querySelectorAll('.qb-hub-tab-item').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.qb-hub-pane').forEach(p => p.classList.remove('active'));
            tab.classList.add('active');
            document.getElementById(tab.dataset.target)?.classList.add('active');

            // Lazy Load Transcript
            if (tab.dataset.target === 'hub-transcript' && activeHubItemId) {
                loadTranscript(activeHubItemId);
            }
        });
    });

    // AI Handler
    dom.aiGenerateBtn.addEventListener('click', async () => {
        // Using activeHubItemId global from scroll tracking or click
        if (!activeHubItemId) return;
        const btn = dom.aiGenerateBtn;
        const originalText = btn.innerHTML;
        btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
        btn.disabled = true;
        dom.hubAiContent.innerHTML = "Đang phân tích...";

        try {
            const res = await fetch(getAiResponseUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', ...csrfHeaders },
                body: JSON.stringify({ item_id: activeHubItemId, prompt_type: 'explanation' })
            });
            const data = await res.json();
            const content = data.html_content || data.response;

            dom.hubAiContent.innerHTML = content;
            const q = currentQuestionBatch.find(q => q.item_id == activeHubItemId);
            if (q) q.ai_explanation = content;
            saveState();

        } catch (e) {
            dom.hubAiContent.innerHTML = '<span class="text-red-500">Lỗi kết nối AI.</span>';
        }
        btn.innerHTML = originalText;
        btn.disabled = false;
    });

    // Note Handlers
    dom.hubNoteSave.addEventListener('click', async () => {
        if (!activeHubItemId) return;
        const content = dom.hubNoteInput.value;
        const btn = dom.hubNoteSave;
        btn.disabled = true;
        btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';

        try {
            await fetch(saveNoteUrlTemplate.replace('0', activeHubItemId), {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', ...csrfHeaders },
                body: JSON.stringify({ content })
            });

            const q = currentQuestionBatch.find(q => q.item_id == activeHubItemId);
            if (q) q.note_content = content;

            updateNoteUI(content);
            saveState();
            showCustomAlert("Đã lưu ghi chú", "success");
        } catch (e) {
            showCustomAlert("Lỗi lưu ghi chú", "error");
        }
        btn.disabled = false;
        btn.innerHTML = "Lưu";
    });

    dom.hubNoteEditBtn.addEventListener('click', () => {
        dom.hubNoteDisplay.classList.add('hidden');
        dom.hubNoteEdit.classList.remove('hidden');
        dom.hubNoteEditBtn.classList.add('hidden');
    });

    dom.hubNoteCancelBtn.addEventListener('click', () => {
        const q = currentQuestionBatch.find(q => q.item_id == activeHubItemId);
        updateNoteUI(q ? (q.note_content || "") : "");
    });

    // Transcript Listeners
    // Transcript Listeners
    if (dom.transcriptEditBtn) {
        dom.transcriptEditBtn.addEventListener('click', () => {
            dom.transcriptContent.classList.add('hidden');
            dom.transcriptEditContainer.classList.remove('hidden');
            dom.transcriptEditBtn.classList.add('hidden');
            dom.transcriptEditActions.classList.remove('hidden');
            dom.transcriptEditor.value = dom.transcriptContent.textContent;
        });
    }

    if (dom.transcriptCancelBtn) {
        dom.transcriptCancelBtn.addEventListener('click', () => {
            dom.transcriptEditContainer.classList.add('hidden');
            dom.transcriptContent.classList.remove('hidden');
            dom.transcriptEditBtn.classList.remove('hidden');
            dom.transcriptEditActions.classList.add('hidden');
        });
    }

    if (dom.transcriptSaveBtn) {
        dom.transcriptSaveBtn.addEventListener('click', async () => {
            if (!activeHubItemId) return;
            const content = dom.transcriptEditor.value;
            const btn = dom.transcriptSaveBtn;

            btn.disabled = true;
            const originalText = btn.innerHTML;
            btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';

            try {
                const url = transcriptUrlTemplate.replace('0', activeHubItemId);
                const updateUrl = url + '/update';

                await fetch(updateUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', ...csrfHeaders },
                    body: JSON.stringify({ transcript: content })
                });

                const q = currentQuestionBatch.find(q => q.item_id == activeHubItemId);
                if (q) q.transcript_content = content;

                renderTranscriptUI(content, true); // Keep edit permission
                showCustomAlert("Đã lưu transcript", "success");

                // Switch back to view mode
                dom.transcriptEditContainer.classList.add('hidden');
                dom.transcriptContent.classList.remove('hidden');
                dom.transcriptEditActions.classList.add('hidden');
                dom.transcriptEditBtn.classList.remove('hidden');

            } catch (e) {
                console.error(e);
                showCustomAlert("Lỗi lưu transcript", "error");
            }
            btn.disabled = false;
            btn.innerHTML = originalText;
        });
    }

    // Close Modal Listeners
    const closeTranscriptModal = () => {
        if (dom.transcriptModal) dom.transcriptModal.classList.add('hidden');
    };
    document.getElementById('close-transcript-modal')?.addEventListener('click', closeTranscriptModal);
    document.getElementById('close-transcript-modal-btn')?.addEventListener('click', closeTranscriptModal);
    document.getElementById('transcript-close-main-btn')?.addEventListener('click', closeTranscriptModal);

    async function loadTranscript(itemId) {
        activeHubItemId = itemId; // Track active item
        const q = currentQuestionBatch.find(q => q.item_id == itemId);
        if (!q) return;

        // Reset UI in Modal
        dom.transcriptLoading.classList.remove('hidden');
        dom.transcriptContent.classList.add('hidden');
        dom.transcriptEmpty.classList.add('hidden');
        dom.transcriptError.classList.add('hidden');
        dom.transcriptEditContainer.classList.add('hidden');
        // dom.transcriptEditBtn visibility handled by renderTranscriptUI

        if (q.transcript_content !== undefined) {
            renderTranscriptUI(q.transcript_content, q.can_edit_transcript);
            dom.transcriptLoading.classList.add('hidden');
            return;
        }

        try {
            const url = transcriptUrlTemplate.replace('0', itemId);
            const res = await fetch(url.replace('0', itemId), {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', ...csrfHeaders }
            });
            const data = await res.json();

            if (data.success) {
                const text = data.transcript;
                q.transcript_content = text || null;
                q.can_edit_transcript = data.can_edit;
                renderTranscriptUI(text, data.can_edit);
            } else {
                if (res.status === 404) {
                    q.transcript_content = null;
                    q.can_edit_transcript = data.can_edit || false;
                    renderTranscriptUI(null, q.can_edit_transcript);
                } else {
                    throw new Error(data.message);
                }
            }
        } catch (e) {
            dom.transcriptError.classList.remove('hidden');
            if (document.getElementById('transcript-error-msg'))
                document.getElementById('transcript-error-msg').textContent = e.message || "Lỗi kết nối.";
        } finally {
            dom.transcriptLoading.classList.add('hidden');
        }
    }

    function renderTranscriptUI(content, canEdit) {
        if (canEdit && dom.transcriptEditBtn) {
            dom.transcriptEditBtn.classList.remove('hidden');
        } else if (dom.transcriptEditBtn) {
            dom.transcriptEditBtn.classList.add('hidden');
        }

        if (content) {
            dom.transcriptContent.classList.remove('hidden');
            dom.transcriptContent.textContent = content;
            dom.transcriptEmpty.classList.add('hidden');
        } else {
            dom.transcriptEmpty.classList.remove('hidden');
            dom.transcriptContent.classList.add('hidden');
        }
    }

    function openTranscript(itemId) {
        if (dom.transcriptModal) {
            dom.transcriptModal.classList.remove('hidden');
            loadTranscript(itemId);
        }
    }

    // === END HUB ===

    function toggleControlButtons(state) {
        const submits = document.querySelectorAll('.js-submit-batch-btn');
        const nexts = document.querySelectorAll('.js-next-batch-btn');
        submits.forEach(btn => btn.style.display = 'none');
        nexts.forEach(btn => btn.style.display = 'none');

        if (state === 'answering') {
            submits.forEach(btn => {
                btn.style.display = 'inline-flex';
                btn.disabled = false;
                btn.innerHTML = '<i class="fas fa-paper-plane"></i> <span class="control-button-text">Gửi đáp án</span>';
            });
            checkCompletionStatus();
        } else if (state === 'submitting') {
            submits.forEach(btn => {
                btn.style.display = 'inline-flex';
                btn.disabled = true;
                btn.style.opacity = '1';
                btn.classList.remove('opacity-50');
                btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Đang gửi...';
            });
        } else if (state === 'submitted') {
            nexts.forEach(btn => btn.style.display = 'inline-flex');
        }
    }

    function handleSessionComplete(endMessage) {
        setText('.js-quiz-group-range', 'Hoàn thành');
        const msgHtml = `<div class="text-center py-12 px-6"><i class="fas fa-check-circle text-5xl text-green-500 mb-4"></i><h3 class="text-xl font-bold text-slate-800 mb-2">Hoàn thành phiên học!</h3><p class="text-slate-500 mb-6">${formatTextForHtml(endMessage.message)}</p><a href="${quizDashboardUrl}" class="cm-btn cm-btn-primary"><i class="fas fa-home"></i> Về Dashboard</a></div>`;
        setHtml('.js-quiz-content', msgHtml);
        toggleControlButtons('complete');
        document.querySelectorAll('.js-end-session-btn').forEach(btn => btn.style.display = 'none');
    }

    async function handleEndSession() {
        if (confirm('Bạn có chắc chắn muốn kết thúc phiên học hiện tại?')) {
            try {
                await fetch(endSessionUrl, { method: 'POST', headers: { 'Content-Type': 'application/json', ...csrfHeaders }, body: JSON.stringify({}) });
                clearState();
                window.location.href = quizDashboardUrl;
            } catch (e) {
                showCustomAlert('Lỗi kết thúc phiên.', 'error');
            }
        }
    }

    document.body.addEventListener('click', (e) => {
        const btn = e.target.closest('button');
        if (!btn) return;
        if (btn.classList.contains('js-submit-batch-btn')) submitAnswerBatch();
        if (btn.classList.contains('js-next-batch-btn')) getNextQuestionBatch();
        if (btn.classList.contains('js-end-session-btn')) handleEndSession();
        if (btn.classList.contains('js-batch-explain-btn')) {
            if (activeHubItemId) openHub(activeHubItemId);
            else openHub(currentQuestionBatch[0]?.item_id);
        }
        if (btn.classList.contains('js-open-transcript-btn')) {
            const itemId = btn.dataset.itemId;
            if (itemId) openTranscript(itemId);
        }
    });

    // Feedback Modal Logic
    const feedbackModal = document.getElementById('feedback-modal');
    if (feedbackModal) {
        const closeBtn = document.getElementById('close-feedback-btn');
        const cancelBtn = document.getElementById('feedback-cancel-btn');
        const submitBtn = document.getElementById('feedback-submit-btn');
        const input = document.getElementById('feedback-input');

        const closeFeedback = () => feedbackModal.classList.remove('open');

        [closeBtn, cancelBtn].forEach(btn => btn?.addEventListener('click', closeFeedback));
        feedbackModal.addEventListener('click', (e) => { if (e.target === feedbackModal) closeFeedback(); });

        submitBtn?.addEventListener('click', () => {
            const content = input.value.trim();
            if (!content) {
                showCustomAlert("Vui lòng nhập nội dung.", "warning");
                return;
            }
            // Simulate API call
            submitBtn.disabled = true;
            submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Đang gửi...';

            setTimeout(() => {
                console.log(`Sending feedback for item ${activeFeedbackItemId}: ${content}`);
                showCustomAlert("Cảm ơn đóng góp của bạn!", "success");
                submitBtn.disabled = false;
                submitBtn.innerHTML = 'Gửi phản hồi';
                closeFeedback();
            }, 800);
        });
    }

    // === EDIT MODAL LOGIC ===
    const editModal = document.getElementById('edit-item-modal');
    if (editModal) {
        const closeBtn = document.getElementById('close-edit-modal-btn');
        const iframe = document.getElementById('edit-item-iframe');
        let currentEditItemId = null;

        window.openEditModal = (url, itemId) => {
            currentEditItemId = itemId;
            if (iframe) iframe.src = url + (url.includes('?') ? '&' : '?') + 'is_modal=true';
            editModal.classList.add('open');
        };

        const closeEditModal = () => {
            editModal.classList.remove('open');
            if (iframe) iframe.src = '';

            // Refresh question data if we have an ID
            if (currentEditItemId) {
                refreshQuestionData(currentEditItemId);
            }
        };

        if (closeBtn) closeBtn.addEventListener('click', closeEditModal);
        editModal.addEventListener('click', (e) => { if (e.target === editModal) closeEditModal(); });
    }

    async function refreshQuestionData(itemId) {
        try {
            // We can use the single item API if available, or just re-fetch batch.
            // Re-fetching batch might be heavy. Let's try single item API if it exists.
            // Usually /learn/quiz_learning/api/items/<id>
            const res = await fetch(`/learn/quiz_learning/api/items/${itemId}`);
            if (!res.ok) throw new Error('Refresh failed');
            const data = await res.json();

            if (data.success && data.item) {
                // Update local state
                const idx = currentQuestionBatch.findIndex(q => q.item_id == itemId);
                if (idx !== -1) {
                    // Merge new data
                    currentQuestionBatch[idx] = { ...currentQuestionBatch[idx], ...data.item };

                    // Re-render ONLY this card? Or replace HTML?
                    // Replace the card HTML
                    const newHtml = buildQuestionCardHtml(currentQuestionBatch[idx], idx);
                    const oldCard = document.querySelector(`.question-card[data-item-id="${itemId}"]`);
                    if (oldCard) {
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = newHtml;
                        const newCard = tempDiv.firstElementChild;
                        oldCard.replaceWith(newCard);

                        // Re-attach handlers for this card's buttons
                        // A bit tricky since attachOptionHandlers attaches to ALL. 
                        // We can just re-run attachOptionHandlers() - it removes old listeners first safely.
                        attachOptionHandlers();
                    }
                    saveState();
                }
            }
        } catch (e) {
            console.error("Failed to refresh item", itemId, e);
        }
    }

    function formatTextForHtml(text) { return text ? String(text).replace(/\n/g, '<br>') : ''; }
    function showCustomAlert(msg, type = 'warning') {
        const container = document.querySelector('.quiz-toast-container') || (() => {
            const c = document.createElement('div'); c.className = 'quiz-toast-container'; document.body.appendChild(c); return c;
        })();
        const toast = document.createElement('div');
        toast.className = `quiz-toast`;
        toast.textContent = msg;
        container.appendChild(toast);
        requestAnimationFrame(() => toast.classList.add('visible'));
        setTimeout(() => { toast.classList.remove('visible'); setTimeout(() => toast.remove(), 300); }, 3000);
    }
</script>
{% endblock %}