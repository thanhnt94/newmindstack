<script>
    /**
    * Memory Power Notification Component
    * Extracted from ui_manager.js for reusability
    * Returns a Promise that resolves when the animation is complete
    * 
    * TIMING CONFIG (adjust these values to change animation duration):
    */
    const MP_ANIMATION_CONFIG = {
        ENTRANCE_DELAY: 50,      // Delay before entrance animation (ms)
        COUNT_DURATION: 400,     // Duration of number count-up animation (ms)
        DISPLAY_TIME: 600,       // Time to display after count-up completes (ms)
        EXIT_DURATION: 150       // Exit fade-out duration (ms)
        // TOTAL â‰ˆ ENTRANCE_DELAY + COUNT_DURATION + DISPLAY_TIME + EXIT_DURATION = ~1200ms
    };

    window.showMemoryPowerFeedback = function (arg1, arg2) {
        return new Promise((resolve) => {
            let config = {};

            // Handle both (oldVal, newVal) and (resultObject) patterns
            if (typeof arg1 === 'object' && arg1 !== null) {
                const res = arg1;
                config = {
                    is_correct: res.is_correct !== undefined ? res.is_correct : true,
                    delta: res.mastery_delta !== undefined ? res.mastery_delta : 0,
                    newVal: res.new_mastery_pct !== undefined ? res.new_mastery_pct : 0,
                    pointsBreakdown: res.points_breakdown || {}
                };
                config.oldVal = config.newVal - config.delta;
            } else {
                config = {
                    oldVal: arg1 || 0,
                    newVal: arg2 || 0,
                    delta: (arg2 || 0) - (arg1 || 0),
                    is_correct: (arg2 || 0) >= (arg1 || 0),
                    pointsBreakdown: {}
                };
            }

            if (config.oldVal === undefined || config.newVal === undefined || config.oldVal === config.newVal) {
                // If no change, but we want to show it for 'incorrect' maybe?
                // For now, if delta is 0, we can still show the current state if it's correct/incorrect?
                // Actually, if delta is 0, it means no progress.
                if (config.delta === 0) {
                    resolve();
                    return;
                }
            }

            const diff = config.delta.toFixed(1);
            const sign = config.delta >= 0 ? '+' : '';
            const isPositive = config.delta >= 0;

            // Create the container
            const container = document.createElement('div');
            container.className = 'fixed inset-0 z-[1000] pointer-events-none flex items-center justify-center';

            // Circle parameters
            const size = 180;
            const strokeWidth = 8;
            const radius = (size - strokeWidth) / 2;
            const circumference = 2 * Math.PI * radius;

            // Use config for transition duration
            const circleDuration = MP_ANIMATION_CONFIG.COUNT_DURATION / 1000;

            container.innerHTML = `
            <div class="relative flex flex-col items-center justify-center p-8 rounded-3xl bg-slate-900/80 backdrop-blur-md border border-white/10 shadow-2xl scale-90 opacity-0 transition-all duration-150 ease-out js-mp-container"
                style="min-width: 240px; min-height: 240px;">
                
                <!-- Glow Effect -->
                <div class="absolute inset-0 ${isPositive ? 'bg-indigo-500/20' : 'bg-rose-500/20'} blur-3xl rounded-full pointer-events-none"></div>

                <!-- Progress Circle -->
                <div class="relative z-10">
                    <svg width="${size}" height="${size}" class="transform -rotate-90 drop-shadow-lg">
                        <!-- Track -->
                        <circle 
                            cx="${size / 2}" cy="${size / 2}" r="${radius}" 
                            stroke="rgba(255,255,255,0.1)" stroke-width="${strokeWidth}" 
                            fill="transparent"
                        />
                        <!-- Indicator -->
                        <circle 
                            cx="${size / 2}" cy="${size / 2}" r="${radius}" 
                            stroke="url(#mp-gradient-new)" stroke-width="${strokeWidth}" 
                            fill="transparent" stroke-linecap="round"
                            style="stroke-dasharray: ${circumference}; stroke-dashoffset: ${circumference - (config.oldVal / 100) * circumference}; transition: stroke-dashoffset ${circleDuration}s cubic-bezier(0.2, 0, 0, 1);"
                            class="js-mp-circle"
                        />
                        <defs>
                            <linearGradient id="mp-gradient-new" x1="0%" y1="0%" x2="100%" y2="100%">
                                <stop offset="0%" stop-color="${isPositive ? '#818cf8' : '#fb7185'}" />
                                <stop offset="100%" stop-color="${isPositive ? '#c084fc' : '#f43f5e'}" />
                            </linearGradient>
                        </defs>
                    </svg>

                    <!-- Center Content -->
                    <div class="absolute inset-0 flex flex-col items-center justify-center text-white">
                        <span class="text-[10px] uppercase font-bold tracking-widest text-indigo-200 mb-1 opacity-80">Mastery</span>
                        <span class="text-5xl font-black js-mp-value tracking-tight drop-shadow-md">${config.oldVal.toFixed(1)}<span class="text-2xl text-indigo-300 ml-0.5">%</span></span>
                        
                        <div class="mt-3 overflow-hidden">
                            <div class="px-3 py-1 rounded-full bg-white/10 border border-white/10 backdrop-blur-sm flex items-center gap-1.5 transform translate-y-4 opacity-0 transition-all duration-150 delay-50 js-mp-diff">
                                <i class="fas ${isPositive ? 'fa-arrow-up' : 'fa-arrow-down'} text-[10px] ${isPositive ? 'text-emerald-400' : 'text-rose-400'}"></i>
                                <span class="text-sm font-bold ${isPositive ? 'text-emerald-300' : 'text-rose-300'}">${sign}${Math.abs(diff)}%</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        `;

            document.body.appendChild(container);

            const containerInner = container.querySelector('.js-mp-container');
            const circle = container.querySelector('.js-mp-circle');
            const valueDisplay = container.querySelector('.js-mp-value');
            const diffBadge = container.querySelector('.js-mp-diff');

            // ENTRANCE ANIMATION
            requestAnimationFrame(() => {
                containerInner.classList.remove('scale-90', 'opacity-0');
                containerInner.classList.add('scale-100', 'opacity-100');

                // Show diff badge slightly later
                setTimeout(() => {
                    diffBadge.classList.remove('translate-y-4', 'opacity-0');
                }, 50);
            });

            // COUNT UP & CIRCLE FILL ANIMATION
            setTimeout(() => {
                // 1. Animate Circle
                const targetOffset = circumference - (config.newVal / 100) * circumference;
                circle.style.strokeDashoffset = targetOffset;

                // 2. Animate Number
                const duration = MP_ANIMATION_CONFIG.COUNT_DURATION;
                const start = performance.now();

                const animateNumbers = (time) => {
                    const timeFraction = Math.min((time - start) / duration, 1);
                    const progress = timeFraction === 1 ? 1 : 1 - Math.pow(2, -10 * timeFraction);
                    const current = config.oldVal + (config.newVal - config.oldVal) * progress;
                    valueDisplay.innerHTML = `${current.toFixed(1)}<span class="text-2xl text-indigo-300 ml-0.5">%</span>`;
                    if (timeFraction < 1) {
                        requestAnimationFrame(animateNumbers);
                    }
                };
                requestAnimationFrame(animateNumbers);

            }, MP_ANIMATION_CONFIG.ENTRANCE_DELAY);

            // EXIT ANIMATION
            const exitStartTime = MP_ANIMATION_CONFIG.ENTRANCE_DELAY + MP_ANIMATION_CONFIG.COUNT_DURATION + MP_ANIMATION_CONFIG.DISPLAY_TIME;
            setTimeout(() => {
                containerInner.classList.remove('scale-100', 'opacity-100');
                containerInner.classList.add('scale-95', 'opacity-0', 'blur-sm');
                setTimeout(() => {
                    container.remove();
                    resolve();
                }, MP_ANIMATION_CONFIG.EXIT_DURATION);
            }, exitStartTime);
        });
    };
</script>