{#
Reusable chat controller that handles polling, sending, open/close state,
and unread badge tracking for any collaborative room type.

Usage example:

{% include _v ~ '/components/chat/chat_widget.html' %}
<script>
  const chatCtrl = window.sharedChat.initChat({
    messagesUrl: '{{ url_for('chat.list_chat_messages', room_type='quiz - battle', room_code=room_code) }}',
    postMessageUrl: '{{ url_for('chat.post_chat_message', room_type='quiz - battle', room_code=room_code) }}',
    currentUserId: {{ current_user_id }},
  pollInterval: 5000,
    csrfToken: document.querySelector('meta[name="csrf-token"]')?.getAttribute('content'),
      elements: {
    messages: document.getElementById('chat-messages'),
      form: document.getElementById('chat-form'),
        input: document.getElementById('chat-input'),
          panel: document.getElementById('chat-panel'),
            openButton: document.getElementById('open-chat-btn'),
              closeButton: document.getElementById('close-chat-btn'),
                unreadBadge: document.getElementById('chat-unread-badge'),
      },
  renderMessages: (messages, ctx) => { /* custom rendering */ },
    });
</script>
#}

<script>
  window.sharedChat = window.sharedChat || (() => {
    function initChat(config = {}) {
      const {
        messagesUrl,
        postMessageUrl,
        currentUserId,
        pollInterval = 5000,
        csrfToken = '',
        elements = {},
        renderMessages,
      } = config;

      const {
        messages: messagesEl,
        form: formEl,
        input: inputEl,
        panel: panelEl,
        openButton,
        closeButton,
        unreadBadge,
      } = elements;

      if (!messagesEl || !formEl || !inputEl) return null;

      let pollHandle = null;
      let latestMessageId = null;
      let lastSeenMessageId = null;
      let hasUnread = false;

      const isOpen = () => panelEl?.classList.contains('open');

      const updateUnreadBadge = () => {
        if (!unreadBadge) return;
        if (hasUnread) {
          unreadBadge.classList.add('is-visible');
          unreadBadge.setAttribute('aria-hidden', 'false');
        } else {
          unreadBadge.classList.remove('is-visible');
          unreadBadge.setAttribute('aria-hidden', 'true');
        }
      };

      const setOpen = (state) => {
        if (panelEl) {
          panelEl.classList.toggle('open', state);
        }

        if (openButton) {
          openButton.classList.toggle('is-active', state);
          openButton.setAttribute('aria-pressed', state ? 'true' : 'false');
        }

        if (state) {
          setTimeout(() => inputEl?.focus({ preventScroll: true }), 120);
          lastSeenMessageId = latestMessageId;
          hasUnread = false;
          updateUnreadBadge();
        }
      };

      const toggle = () => setOpen(!isOpen());

      const trackUnread = (messages = []) => {
        if (!Array.isArray(messages) || !messages.length) {
          latestMessageId = null;
          hasUnread = false;
          updateUnreadBadge();
          return;
        }

        const newestId = Number(messages[messages.length - 1]?.message_id) || null;

        if (latestMessageId === null) {
          latestMessageId = newestId;
          lastSeenMessageId = newestId;
          hasUnread = false;
          updateUnreadBadge();
          return;
        }

        latestMessageId = newestId;

        if (isOpen()) {
          lastSeenMessageId = newestId;
          hasUnread = false;
        } else if (newestId && (lastSeenMessageId === null || newestId > lastSeenMessageId)) {
          hasUnread = true;
        }

        updateUnreadBadge();
      };

      const renderList = (messages = []) => {
        if (typeof renderMessages === 'function') {
          renderMessages(messages, { currentUserId });
          return;
        }

        messagesEl.innerHTML = '';
        if (!messages.length) {
          messagesEl.innerHTML = '<p class="text-sm text-slate-400 text-center py-4">Chưa có tin nhắn.</p>';
          return;
        }

        messages.forEach((msg, idx) => {
          const isMe = msg.user_id === currentUserId;
          const showAvatar = !isMe && (idx === 0 || messages[idx - 1]?.user_id !== msg.user_id);
          const showName = !isMe && showAvatar;

          const item = document.createElement('div');
          item.className = `chat-message-row ${isMe ? 'chat-me' : 'chat-other'}`;

          // Get initials for avatar
          const initials = (msg.username || 'U').substring(0, 2).toUpperCase();
          const avatarColor = `hsl(${(msg.user_id || 0) * 137 % 360}, 60%, 55%)`;

          item.innerHTML = `
            ${!isMe ? `<div class="chat-avatar ${showAvatar ? '' : 'invisible'}" style="background: ${avatarColor}">${initials}</div>` : ''}
            <div class="chat-bubble-wrapper">
              ${showName ? `<div class="chat-sender-name">${msg.username || 'Người chơi'}</div>` : ''}
              <div class="chat-bubble">${msg.content}</div>
            </div>
          `;
          messagesEl.appendChild(item);
        });

        // Scroll to bottom
        messagesEl.scrollTop = messagesEl.scrollHeight;
      };

      const loadMessages = async () => {
        try {
          const res = await fetch(messagesUrl, { credentials: 'same-origin' });
          const data = await res.json();
          const messages = data.messages || [];
          renderList(messages);
          trackUnread(messages);
        } catch (err) {
          console.error('Chat load error:', err);
        }
      };

      const sendMessage = async (content) => {
        const text = (content || '').trim();
        if (!text) return;

        inputEl.disabled = true;
        try {
          const res = await fetch(postMessageUrl, {
            method: 'POST',
            credentials: 'same-origin',
            headers: {
              'Content-Type': 'application/json',
              ...(csrfToken ? { 'X-CSRFToken': csrfToken } : {}),
            },
            body: JSON.stringify({ content: text }),
          });

          if (!res.ok) {
            const payload = await res.json().catch(() => ({}));
            throw new Error(payload?.description || 'Không thể gửi tin nhắn.');
          }

          inputEl.value = '';
          await loadMessages();
        } catch (err) {
          console.error('Chat send error:', err);
        } finally {
          inputEl.disabled = false;
          inputEl.focus();
        }
      };

      const startPolling = () => {
        if (pollHandle) return;
        pollHandle = setInterval(loadMessages, pollInterval);
      };

      const stopPolling = () => {
        if (!pollHandle) return;
        clearInterval(pollHandle);
        pollHandle = null;
      };

      formEl.addEventListener('submit', (event) => {
        event.preventDefault();
        sendMessage(inputEl.value || '');
      });

      openButton?.addEventListener('click', (event) => {
        event.preventDefault();
        toggle();
      });

      closeButton?.addEventListener('click', () => setOpen(false));

      loadMessages();
      startPolling();

      return {
        loadMessages,
        sendMessage,
        setOpen,
        toggle,
        isOpen,
        startPolling,
        stopPolling,
        trackUnread,
        updateUnreadBadge,
      };
    }

    return { initChat };
  })();
</script>
